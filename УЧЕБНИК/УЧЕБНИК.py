# -*- coding: utf-8 -*-
#  0 -> class regular
#  1 -> class str()
#  2 -> class list():
#  3 -> class set&dict():
#  4 -> class pyautogui():
#  5 -> class try():
#  6 -> class file():
#  7 -> class os():
#  8 -> class shutil():
#  9 -> class tkinter():
#  10 -> class sys():
import functools
import math
import string

"""Есть по крайней мере три способа создать кортеж.
Это кажется немного замысловатым, но дело в том, что кортеж задаётся не скобками, а запятыми."""
t = tuple([1, 2, 3])
t = (1, 2, 3)
t = 1, 2, 3, # Можно и без скобок
# Выхлоп / type(t) -> tuple /

"""Сложение больших и маленьких чисел"""
sum((1.23e+18, 100, -1.23e+18)) # Выхлоп / 0.0 / # Исчезло 100
# Ошибка исправляется так:
math.fsum([1.23e+18, 100, -1.23e+18]) #  Выхлоп / 100.0 /

"""Inf/-Inf и NaN"""
float('nan') == float('nan') # False (NaN никогда не равны друг другу)
float('inf') == float('inf') # True
# Ошибка исправляется так: math.isinf(); math.isnan()

"""eval() интерпретирует строку как код. 
⚫ Надо быть осторожным c eval(input()): eval("__import__('os').system('rm -R *')")"""
eval("1+1")  # Выхлоп /2/

"""Тонкости при определении функций с аргументами по умолчанию:
⚫ Значения, назначенные значениями по умолчанию, связываются только один раз"""
x = 123
def test(a, b=x):
    print(a, b)
test(1) # Выхлоп /1 123/
x = 'New value'
test(2) # Выхлоп /1 123/ # Эффекта нет, т.к тип x (int) — неизменяемый объект
"""⚫ В lambda-выражениях свободные переменные (не аргументы) связываются во время выполнения, а не во время определения"""
x = 10; test = lambda y: x + y
x = 30; test(30) # Выхлоп /60/ 30 + 30
# Для того, чтобы функция захватывала переменную x во время определения, нужно использовать значение по умолчанию.
x = 10; test = lambda y, x=x, : x + y
x = 30; test(30) # Выхлоп /40/ 10 + 30
"""⚫ Значения, назначенные значениями по умолчанию, всегда должны быть неизменяемыми объектами (None, int, bool, tuple, str ...)"""
def test(a, b=[]):
    print(a, b); return b
x = test(1) # Выхлоп /1 []/ #
x.append('О нет!!!')
test(1) # Выхлоп /1 ['О нет!!!']/  Значение по умолчанию изменилось.

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class extraHacks(): # Экстра-фишки 3.7+
    1E6 = 100_000_000 # Сокращенная запись числа
    bit = 2; bit <<= 9 # Сдвиг на 9 битов влево (10 ~> 10_000_000_000)
    bit = 32; bit >>= 2 # Сдвиг на 2 бита вправо (удаление справа 2 битов) (32 ~> 16 ~> 8)
    bit |= 0b10 # Операция ИЛИ -  если справа есть пустые биты (0), то они заменяются (1) (1_000 ~> 1_010)
    bit >> bit.bit_length()-2 & 0b11

    from dataclasses import dataclass
    @dataclass # (frozen=True) запрет на изменение полей
    class Edge: # Создаёт автоматически метод  __init__(), который создаёт экземпляры
        u: int  # >>> print(Edge('NodeA', 'NodeB'))
        v: int  # NodeA -> NodeB
        def __str__(self): return f"{self.u} -> {self.v}"

    old = {**dict1, **dict1} # Раньше объединение двух словарей в один новый словарь
    new = dict1 | dict2 # Сейчас то же самое можно сделать так (python 3.9)

    import pdb; pdb.set_trace() # Раньше отладка делалась так
    breakpoint() # Сейчас то же самое можно сделать так (python 3.7)

    """Присваивающее выражение:
     Новый оператор `:=` позволяет присваивать значения переменным внутри выражений (python 3.8)"""
    if (n := len(list_)) > 10: print(f"List is too long ({n} elements, expected <= 10)")

    """Поддержка f-строками `=` для самодокументирующихся выражений и отладки (python 3.8)"""
    print(f'List is too long  {n=}') # Выхлоп / "List is too long n=10" /

    """Positional-only аргументы (python 3.8)
    Так можно указать, какие параметры функций передавать через синтаксис именованных аргументов, а какие нет."""
    def f(a, b, /, c, d, *, e, f): print("Positional-only parameters", a, b, c, d, e, f)
    f(10, 20, 30, d=40, e=50, f=60)     # OK
    f(10, b=20, c=30, d=40, e=50, f=60) # Ошибка — `b` не может быть именованным аргументом
    f(10, 20, 30, 40, 50, f=60)         # Ошибка — `e` обязан быть именованным аргументом


# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class regular_expression(): # Регулярные выражения — поиск нужной инфы внутри текстового документа.
    # Сначала с помощью регулярных выражений описываем шаблон, а потом можем проверить подходит-ли данная строка под наш шаблон.
    r"Hello\nworld" # (raw) — сырая строка
    import re
    """ описание функций /берёт шаблон,строку / <re.Match object; span=(интервал), match="шаблон" >"""
    re.match()   # Проверяет подходит ли строка под данный шаблон     <span=(0, 3), match='abc'>
    re.search()  # Находит первую подстроку подходящую под наш шаблон <span=(5, 8), match='abc'>
    [(m.start(0), m.end(0)) for m in re.finditer(pattern, s)] # Список индексов вхождений шаблона в строку
    re.findall()  # Находит все подстроки данной строки подходящей под данный шаблон -> ['aac', 'abc', 'acc']
    re.sub(pattern, "ass", str, k)  # substitution заменить все вхождения подстрок подходящих под данный шаблон чем-то ->'ass,ass,ass'k раз

    """ Метод re.sub ( pattern, repl, string, max=0)
    Заменяет все вхождения ( pattern ) в ( string ) на ( repl)"""
    born = "05-03-1987 #  Дата рождения "
    #  Удалим комментарий из строки
    dob = re.sub(r'# .*$', "", born)
    print("Дата рождения:", dob)
    #  Выхлоп / Дата рождения: 05-03-1987 /

    #  Удаляет все заглавные
    re.sub("([А-ЯЁ]+)", " ", born)
    #  Выхлоп / ата рождения  /

    #  Удаляет все гласные буквы
    re.sub(r"[aeiouAEIOU]", '', str)

    #  Заменим дефисы на точки
    re.sub(r'-', ".", born)
    #  Выхлоп /  #  05.03.1987 #  Дата рождения  /

    #  Поставить пробелы перед заглавными буквами
    re.sub('([A-Z])', r" \1", born)


     []   # (класс символов) Находить любые символы заключенные в квадратных скобках /[a-zA-Z]-все буквы англ алфавита/
    [^ ]  # (отрицание класа символов). Находить, любые символы не заключенные в квадратных скобках
    (xyz) # (группа символов) Находить только символы xyz в указанном порядке

    | # (чередование) Находить либо буквы до, либо буквы после символа
    ^ # Находить совпадения только в том случае, если шаблон будет в конце строки  / ^(H|h)ello /
    $ # Находить совпадения только в том случае, если шаблон будет в конце строки / goodbye(\.)$ /
    * # любое кол-во повторов включая 0 /"b+" только положительное число b/
    ? # 0 или 1 кол-во повторов        /"b?"/
    {k} # Указанное число повторов /{1,5} интервал/
    ab *  # a, за которым следует ноль или более b
    ab +  # a, за которым следует одна или более b
    ab?   # a, за которым следует ноль или одна b

     . # любой отдельной символ, кроме разрыва строки
    \d # [0-9] — Цифры
    \D # [^0-9] — Не цифры
    \s # [ \t\n\r\f\v] — пробельные символы
    \S # [^ \t\n\r\f\v]
    \w # [a-zA-Z0-9] — буквы+цифры
    \W # [^a-zA-Z0-9]

    # +  — (жадный поиск) самое длинное значение
    # +? — (нежадный поиск) короткие значения

    (?=...) """Положительное опережающее условие (Lookahead)
    [?] [?] Находит все совпадения, за которыми следует определенный шаблон"""
    # (T|t)he(?=\sfat) => The fat cat sat on the mat.
    #  Выхлоп / The / перед fat

    (?!...) """Отрицательное  опережающее условие
    [?] Находит все совпадения, за которыми НЕ следует определенный шаблон"""
    # (T|t)he(?!\sfat) => The fat cat sat on the mat.
    #  Выхлоп / the / перед mat

    (?<=...) """Положительное ретроспективное условие (Lookbehind)
    [?] Находит все совпадения, которым предшествует определенный шаблон"""
    # (?<=(T|t)he\s)(fat|mat) >= The fat cat sat on the mat.
    #  Выхлоп / fat mat / после The и the

    (?<!...) """Отрицательное  ретроспективное условие
    [?] Находит все совпадения, которым НЕ предшествует определенный шаблон"""
    # (?<!(T|t)he\s)(cat) >= The fat cat sat on the mat.
    #  Выхлоп / fat mat / после The и the

    i # (insensitive) Поиск без учета регистра
    g #	Глобальный поиск: поиск шаблона во всем входном тексте
    m # Мультистроковой поиск: Якоря применяются к каждой строке.

    #     The =V=> The fat cat sat on the mat =  Выхлоп/  The /
    # /The/gi =S=> The fat cat sat on the mat =  Выхлоп/ The the /

    # /.at(.)?$/   =V=> The fat\n cat sat\n on the mat =  Выхлоп/  mat /
    # /.at(.)?$/gm =S=> The fat\n cat sat\n on the mat =  Выхлоп/ fat sat mat /

    address = re.compile("""
        # Имя состоит из букв и может включать символы точки "."
        # В сокращенных вариантах обращения и инициалах
        ((?P<name>
            ([\w.,]+\s+)*[\w.,]+)
            \s*
            # Адреса электронной почты заключаются в угловые скобки
            # < >, но только если найдено имя, поэтому открывающая
            # Угловая скобка включена в эту группу
            <
        )? # Полное имя является необязательным элементом
        # Собственно электронный адрес: username@domain.tld
        (?P<email>
            [\w\d.+-]+ # Имя пользователя
            @
            ([\w\d.]+\.)+ # Префикс имени домена
            (com|org|edu) # Ограничение списка доменов верхнего уровня
        )
        >? # Необязательная закрывающая угловая скобка
    """, re.VERBOSE)
    address.search(' First M. Last <first.last@example.com>')
    # Выхлоп / Name : First M. Last
    #          Email: first.last@example.com /

    """
    pattern=r"\d+" # Пока символ является числом склеивать
    r"[A-Z]{5}" делит сообщение по 5 букв 
    <a href="https://stepic.org/porn.html">1</a>   
    r'<a[^>]*?href="(.*?)"[^>]*?>' — вытаскивает ссылку https://stepic.org/porn.html
    r'<a.*?href=".*?:\/\/((?:\w|-)+(?:\.(?:\w|-)+)+)' — вытаскивает stepic.org"""


# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class str_and_string():
    str_ = "это пример строки."

    """capitalize():
    Возвращает копию строки с преобразованием только первого символа в заглавную букв."""
    str_.capitalize()
    #  Выхлоп / 'Это пример строки.' /

    """Метод title()
    Возвращает копию строки в которой первые символы всех слов идут с заглавной буквы."""
    str_.title() #  Выхлоп / 'Это Пример Строки.' /
    #_____ or _____ #
    string.capwords(str_) #  Выхлоп / 'Это Пример Строки.' /

    """Метод zfill()
    Дополняет указанную строку нулями слева, до указанной минимальной длины."""
    str(12).zfill(7) #  Выхлоп / '001' /

    """Метод swapcase()
    Возвращает копию строки в которой все символы, основанные на регистре, поменялись местами"""
    'Кот ОбОрМот!'.swapcase() #  Выхлоп / 'кОТ оБоРмОТ!' /

    """Метод find() 
    Возвращает индекс первого вхождения одной строки в другую или -1
    ⚫ В отличие от index() не вызывает ошибки ValueError"""
    str_.find("?") # Выхлоп / -1 /
    str_.startswith("Hi")  # Можем узнать начинается ли str с кортежа ("Hi","hello") или другой строки
    str_.endswith(".py")  # Можем узнать заканчивается ли str кортежем (".py","png") или другой строкой
    str_.rstrip('m')  # Убирает указанный символ в конце строки  str.rstrip() убирает все пробелы и /\n/ в конце строки
    str_.lstrip('m')  # Убирает указанный символ в начале строки
    str_.strip('m')  # Убирает указанный символ в конце и в начале строки

    """Метод replace(a,b,k=None): заменяет  a->b, k раз внутри str"""
    str_.replace(",", ", ", 5)

    # Мульти-замена
    "Swap vowels for numbers.".translate(str.maketrans('aeiou', '12345'))
    # Выхлоп /  `Sw1p v4w2ls f4r n5mb2rs.` /
    "Swap about.".translate({ord("a"): "b", ord("b"): "a"})
    # Выхлоп / `Swbp baout.` /

    """Метод split(sep=" ", maxsplit), возвращает список всех слов в строке, используя sep в качестве разделителя, при необходимости, можно ограничить число разделений."""
    str_.split()  #  Выхлоп /  ['это', 'пример', 'строки.']  /
    str_.split('р', maxsplit=1)  #  Выхлоп /  ['это п', 'имер строки.'] /

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class list():
    list_=['физика', 'химия', 'математика'], obj = [], list = (), seq = [], index = []
    a = [i for i in range(31)]
    # Выхлоп / a = [0, 1, 2, 3, ... , 30]

    list.insert(index, obj), """ Вставляет объект obj в список по смещению индекса"""
    list_.insert(1, 'биология')
    #  Выхлоп / ['физика', 'биология', 'химия', 'математика'] /

    list.extend(seq), """ Объединяет 2 списка / всё равно, что (+)"""
    list_.extend([0, 1, 2, 3, 4])
    #  Выхлоп / ['физика', 'химия', 'математика', 0, 1, 2, 3, 4] /

    list.pop(obj), """ Удаляет и возвращает объект по индексу или последний из списка"""
    list_.pop(1)
    #  Выхлоп / 'химия' /

    list.remove(obj), """ Удаляет объект obj из списка на месте"""
    list_.remove('биология')

    list.reverse(), """ Изменяет объекты списка на месте."""
    list_.reverse()

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class set_dict():
    """ Порядок ключей в словарях теперь гарантированно совпадает с порядком их вставки, это добавлено в спецификацию. (python 3.7)"""

    """ Объединение двух словарей в один новый словарь """
    d1 = {"AAA": 30, "ZZZ": 30, }
    d2 = {"AAA": 31, "ZZZ": 30, }
    # ⚫ При пересечение ключей берётся значение из последнего словаря
    dict_ = {**d1, **d2} #=> {'AAA': 31, 'ZZZ': 30}

    """Найти общие ключи|значения в словарях"""
    d1.keys() & d2.keys()  #=>  {'AAA', 'ZZZ'} общие ключи
    d1.keys() - d2.keys()  #=>  set() ключи 1 словаря без ключей 2
    d1.items() & d2.items()  #=>  {('ZZZ', 30)} общие пары

    """ update() обновляет/дополняет словарь <смотри collections.ChainMap>,
     перезаписывая существующие ключи новыми значениями. Если ключ в словаре отсутствует, то он добавляется."""
    d1.update({"ZZZ": 31}) # {'AAA': 30, 'ZZZ': 0}
    d1.update([('BBB', 30), ('CCC', 30)]) # {'AAA': 30, 'ZZZ': 0, 'BBB': 30, 'CCC': 30}

    """ Создание нового словаря из старого без ключей "ZZZ", "XXX" """
    dict_ = {key: dict_[key] for key in dict_.keys() - {"ZZZ", "XXX"}}

    """ Найти max|min значение в словаре"""
    dict_ = {"key1": 30, "key2": 20, "key3": 10, }
    min(dict_, key=lambda key: dict_[key]) #=> 'key3'
    max(zip(dict_.values(), dict_.keys())) #=> (30, 'key1')

    """ Отсортировать словарь по значениям """
    sorted(dict_.items(), key=lambda item: item[1])
    # Выхлоп / [('key3', 10), ('key2', 20), ('key1', 30)]/

    """Отсортировать список словарей по значению словаря  >смотри itemgetter<"""
    list_to_be_sorted = [{'name': 'Homer', 'age': 39}, {'name': 'Bart', 'age': 10}]
    sorted(list_to_be_sorted, key=lambda k: k['name'])# По 1 ключу
    sorted(list_to_be_sorted, key=lambda k: (k['name'], k['age']))# По 2м ключам
    # Выхлоп / [{'name': 'Bart', 'age': 10}, {'name': 'Homer', 'age': 39}]/

    import collections
    """defaultdict() - подкласс словаря
    ⚫ Попытка доступа к отсутствующему ключу его создаёт и инициализирует, используя принятую по умолчанию фабрику, то есть в данном примере list()"""
    dd = collections.defaultdict(list)
    dd['colors'] += ['red', 'green', 'blue']
    # Выхлоп / defaultdict(list, {'colors': ['red', 'green', 'blue']})/

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class functools():
    """Модуль functools предоставляет функции и типы, поддерживающие функциональное программирование в python
    Предоставляемые модулем functools инструменты позволяют адаптировать или расширять функции и другие вызываемые объекты без полного их переписывания."""

    """Функция partial(func, *a, *k) создает новую функцию, путем фиксирования части аргументов func"""
    def test(a, b, c, d):
        print(a, b, c, d)
    test1 = functools.partial(test, 1, 2, d=4) # a = 1, b = 2, d =  4
    test1('Ого!')  # Выхлоп / 1 2 Ого! 4/

    """Декоратор мемоизации lru_cache(max_size=128, typed=False) обертывает функцию кешем LRU (least recently used)
    Если аргумент typed имеет значение True, то аргументы, которые при сравнении оказываются равными, но относятся к различным типам, например 23 и 23.0, кешируются по-отдельности."""
    @functools.lru_cache(maxsize=32)
    def test(a, b, /): return a**2 + b**2
    for x, y in zip([1, 2, 3, 1, 1], [1, 2, 3, 1, 1]): test(x, y)
    print(test.cache_info()) # Выхлоп / CacheInfo(hits=2, misses=3, maxsize=32, currsize=3) /

    """Декоратор класса total_ordering оборачивается вокруг класса, который предоставляет по крайней мере один метод, выполняющий проверку на неравенство, например lt, а также eq.
    Исходя из существующих методов класса класс декоратора total_ordering добавляет в него остальные методы, выполняющие проверку на неравенство, что избавляет от необходимости самостоятельно добавлять шаблонный код"""
    @functools.total_ordering
    class Integer():
        def __init__(self, number):
            self.number = int(number)

        def __eq__(self, other):
            if self.__class__ is not other.__class__: return NotImplemented
            return self.number == other.number

        def __lt__(self, other):
            if self.__class__ is not other.__class__: return NotImplemented
            return self.number < other.number

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class TryExcept():
    try:  ...
    except (TypeError,ValueError)  as e:  """ except ValueError: выводит ошибку если введён  не тот тип, TypeError"""
        print("Error! Print only INT numbers!")  ,
        print(e.args)
    except: continue  # Перенаправляет (игнорирует) ошибку
    finally: ... # Выполнится всегда
    else: ... # Выполнится, если ошибки не произошло


    """ Повторное возбуждение исключения"""
    try: ...
    except Exception  as e:
        print("У нас проблемы")
        raise

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class cook():
    from collections import deque
    # Создаёт последовательность с максимальной длиной 3
    history = deque(maxlen=3)
    # [1, 2, 3] + [4] => [2, 3, 4]

    """ Использование ChainMap + argparse. <смотри dict.update()> ChainMap() группирует несколько словарей"""
    from collections import ChainMap
    defaults = {'ip': 'localhost', 'port': 7777}
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '—ip')
    parser.add_argument('-p', '—port')

    args = parser.parse_args() # Возвращает Namespace(ip=None, port=None)
    new_dict = {key: value for key, value in vars(args).items() if value} # vars() возвращает словарь пространства имен объекта
    # Поиск ключей в ChainMap() происходит последовательно, слева на право, во всех добавленных словарях, пока не будет найден соответствующий ключ
    settings = ChainMap(new_dict, defaults)

    from itertools import accumulate
    list(accumulate(['i', 'have','no','space']))
    # Выхлоп / ['i', 'ihave', 'ihaveno', 'ihavenospace'] /

    """ Сounter помогает найти количество повторений"""
    words = ['spam', 'egg', 'spam', 'counter', 'counter', 'counter']
    word_count = collections.Counter()
    for word in words: word_count[word] += 1
    # Выхлоп / word_count = Counter({'counter': 3, 'spam': 2, 'egg': 1})

    word_count = collections.Counter(words)
    print(word_count.most_common(2))
    # Выхлоп / {'counter': 3, 'spam': 2} /

    collections.Counter('abracadabra').most_common(3)
    # Выхлоп / [('a', 5), ('r', 2), ('b', 2)] /

    import heapq
    arr = [1, 2, 3, 123, 111, 234]
    print(heapq.nlargest(3, arr)) # [234, 123, 111]
    print(heapq.nsmallest(3, arr))# [1, 2, 3]

    heapq.heapify(arr) # Сортировка
    print(arr[0], arr[-1])   # min и max значения
    heapq.heappush(arr, 2)   # Добавление
    print(heapq.heappop(arr))# Возвращает min элемент, удаляет его

    heapq.heappush(queue, (priotiry, index, item))# Добавление в очередь с приоритетом
    heapq.heappop(queue)[-1] # Удаление из очереди

    """Группировка по значению конкретного поля"""
    import collections
    data = [{'n': 'Artem', 'a': 39}, {'n': 'bard', 'a': 10},
            {'n': 'homer', 'a': 39}, {'n': 'nata', 'a': 10}]
    group_by_age = collections.defaultdict(list)
    for row in data:
        group_by_age[row["a"]].append(row)
    # {39: [{'n': 'Artem', 'a': 39}, {'n': 'homer', 'a': 39}],
    #  10: [{'n': 'bard',  'a': 10},  {'n': 'nata',  'a': 10}]}

    """ Вернуть все возможные перестановки массива """
    import itertools
    arr = [1, 2, 3]
    pr = [i for i in itertools.permutations(arr, 2)]


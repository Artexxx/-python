# -*- coding: utf-8 -*-
import collections
from bisect import bisect
from dataclasses import dataclass
import pdb
import functools
import itertools
import math
import operator
import string
import traceback
import collections.abc
from collections import namedtuple
from socket import AF_INET, SOCK_STREAM, socket
from requests import requests

"""Есть по крайней мере три способа создать кортеж.
Это кажется немного замысловатым, но дело в том, что кортеж задаётся не скобками, а запятыми."""
t = tuple([1, 2, 3])
t = (1, 2, 3)
t = 1, 2, 3,  # Можно и без скобок
# Выхлоп / type(t) -> tuple /

"""Сложение больших и маленьких чисел"""
sum((1.23e+18, 100, -1.23e+18))  # Выхлоп / 0.0 / # Исчезло 100
# Ошибка исправляется так:
math.fsum([1.23e+18, 100, -1.23e+18])  # Выхлоп / 100.0 /

"""Inf/-Inf и NaN"""
float('nan') == float('nan')  # False (NaN никогда не равны друг другу)
float('inf') == float('inf')  # True
# Ошибка исправляется так: math.isinf(); math.isnan()

"""eval() интерпретирует строку как код. 
⚫ Надо быть осторожным c eval(input()): eval("__import__('os').system('rm -R *')")"""
eval("1+1")  # Выхлоп /2/

"""Тонкости при определении функций с аргументами по умолчанию:
⚫ Значения, назначенные значениями по умолчанию, связываются только один раз"""
x = 123
def test(a, b=x):
    print(a, b)
test(1)  # Выхлоп /1 123/
x = 'New value'
test(2)  # Выхлоп /1 123/ # Эффекта нет, т.к тип x (int) — неизменяемый объект
"""⚫ В lambda-выражениях свободные переменные (не аргументы) связываются во время выполнения, а не во время определения"""
x = 10; test = lambda y: x + y
x = 30; test(30)  # Выхлоп /60/ 30 + 30
# Для того, чтобы функция захватывала переменную x во время определения, нужно использовать значение по умолчанию.
x = 10; test = lambda y, x=x,: x + y
x = 30; test(30)  # Выхлоп /40/ 10 + 30
"""⚫ Значения, назначенные значениями по умолчанию, всегда должны быть неизменяемыми объектами (None, int, bool, tuple, str ...)"""
def test(a, b=[]):
    print(a, b); return b
x = test(1)  # Выхлоп /1 [] /
x.append('О нет!!!')
test(1)  # Выхлоп /1 ['О нет!!!']/  Значение по умолчанию изменилось.

"""TODO: Объяснить замкнутый список"""
list_ = [1, 2, 3, 4]
list_.append(list_) # Выхлоп / [1, 2, 3, 4, [...]] /
list_[4][4][4][4][4][4][4][4][4][4] == list_ # Выхлоп / True /

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class extraHacks():  # Экстра-фишки 3.7+
    1E6 = 100_000_000  # Сокращенная запись числа
    bit = 2;  bit <<= 9  # Сдвиг на 9 битов влево (10 ~> 10_000_000_000)
    bit = 32; bit >>= 2  # Сдвиг на 2 бита вправо (удаление справа 2 битов) (32 ~> 16 ~> 8)
    bit |= 0b10  # Операция ИЛИ -  если справа есть пустые биты (0), то они заменяются (1) (1_000 ~> 1_010)
    bit >> bit.bit_length() - 2 & 0b11

    @dataclass  # (frozen=True) — запрет на изменение полей
    class Edge: # Создаёт автоматически метод  __init__(), который создаёт экземпляры
        u: int  # >>> print(Edge('NodeA', 'NodeB'))
        v: int  # NodeA -> NodeB
        def __str__(self): return f"{self.u} -> {self.v}"

    old = {**dict1, **dict1}  # Раньше объединение двух словарей в один новый словарь
    new = dict1 | dict2  # Сейчас то же самое можно сделать так (python 3.9)

    pdb.set_trace() # Раньше отладка делалась так
    breakpoint()    # Сейчас то же самое можно сделать так (python 3.7)

    """Присваивающее выражение:
     Новый оператор `:=` позволяет присваивать значения переменным внутри выражений (python 3.8)"""
    if (n := len(list_)) > 10: print(f"List is too long ({n} elements, expected <= 10)")

    """Поддержка f-строками `=` для самодокументирующихся выражений и отладки (python 3.8)"""
    print(f'List is too long  {n=}')  # Выхлоп / "List is too long n=10" /

    """Positional-only аргументы (python 3.8)
    Так можно указать, какие параметры функций передавать через синтаксис именованных аргументов, а какие нет."""
    def f(a, b, /, c, d, *, e, f): print("Positional-only parameters", a, b, c, d, e, f)
    f(10, 20, 30, d=40, e=50, f=60)  # OK
    f(10, b=20, c=30, d=40, e=50, f=60)  # Ошибка — `b` не может быть именованным аргументом
    f(10, 20, 30, 40, 50, f=60)  # Ошибка — `e` обязан быть именованным аргументом


# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class regular_expression():  # Регулярные выражения — поиск нужной инфы внутри текстового документа.
    # Сначала с помощью регулярных выражений описываем шаблон, а потом можем проверить подходит-ли данная строка под наш шаблон.
    r"Hello\nworld"  # (raw) — сырая строка
    import re
    """ описание функций /берёт шаблон,строку / <re.Match object; span=(интервал), match="шаблон" >"""
    re.match()  # Проверяет подходит ли строка под данный шаблон     <span=(0, 3), match='abc'>
    re.search()  # Находит первую подстроку подходящую под наш шаблон <span=(5, 8), match='abc'>
    [(m.start(0), m.end(0)) for m in re.finditer(pattern, s)]  # Список индексов вхождений шаблона в строку
    re.findall()  # Находит все подстроки данной строки подходящей под данный шаблон -> ['aac', 'abc', 'acc']
    re.sub(pattern, "ass", str,k)  # substitution заменить все вхождения подстрок подходящих под данный шаблон чем-то ->'ass,ass,ass'k раз

    """ Метод re.sub ( pattern, repl, string, max=0)
    Заменяет все вхождения ( pattern ) в ( string ) на ( repl)"""
    born = "05-03-1987 #  Дата рождения "
    #  Удалим комментарий из строки
    dob = re.sub(r'# .*$', "", born)
    print("Дата рождения:", dob)
    #  Выхлоп / Дата рождения: 05-03-1987 /

    #  Удаляет все заглавные
    re.sub("([А-ЯЁ]+)", " ", born)
    #  Выхлоп / ата рождения  /

    #  Удаляет все гласные буквы
    re.sub(r"[aeiouAEIOU]", '', str)

    #  Заменим дефисы на точки
    re.sub(r'-', ".", born)
    #  Выхлоп /  #  05.03.1987 #  Дата рождения  /

    #  Поставить пробелы перед заглавными буквами
    re.sub('([A-Z])', r" \1", born)

     []   # (класс символов) Находить любые символы заключенные в квадратных скобках /[a-zA-Z]-все буквы англ алфавита/
    [^ ]  # (отрицание класа символов). Находить, любые символы не заключенные в квадратных скобках
    (xyz) # (группа символов) Находить только символы xyz в указанном порядке

    | # (чередование) Находить либо буквы до, либо буквы после символа
    ^ # Находить совпадения только в том случае, если шаблон будет в конце строки  / ^(H|h)ello /
    $ # Находить совпадения только в том случае, если шаблон будет в конце строки / goodbye(\.)$ /
    * # любое кол-во повторов включая 0 /"b+" только положительное число b/
    ? # 0 или 1 кол-во повторов        /"b?"/
    {k} # Указанное число повторов /{1,5} интервал/
    ab *  # a, за которым следует ноль или более b
    ab +  # a, за которым следует одна или более b
    ab?   # a, за которым следует ноль или одна b

     . # любой отдельной символ, кроме разрыва строки
    \d # [0-9] — Цифры
    \D # [^0-9] — Не цифры
    \s # [ \t\n\r\f\v] — пробельные символы
    \S # [^ \t\n\r\f\v]
    \w # [a-zA-Z0-9] — буквы+цифры
    \W # [^a-zA-Z0-9]

    # +  — (жадный поиск) самое длинное значение
    # +? — (нежадный поиск) короткие значения

    (?=...) """Положительное опережающее условие (Lookahead)
    [?] [?] Находит все совпадения, за которыми следует определенный шаблон"""
    # (T|t)he(?=\sfat) => The fat cat sat on the mat.
    #  Выхлоп / The / перед fat

    (?!...) """Отрицательное  опережающее условие
    [?] Находит все совпадения, за которыми НЕ следует определенный шаблон"""
    # (T|t)he(?!\sfat) => The fat cat sat on the mat.
    #  Выхлоп / the / перед mat

    (?<=...) """Положительное ретроспективное условие (Lookbehind)
    [?] Находит все совпадения, которым предшествует определенный шаблон"""
    # (?<=(T|t)he\s)(fat|mat) >= The fat cat sat on the mat.
    #  Выхлоп / fat mat / после The и the

    (?<!...) """Отрицательное  ретроспективное условие
    [?] Находит все совпадения, которым НЕ предшествует определенный шаблон"""
    # (?<!(T|t)he\s)(cat) >= The fat cat sat on the mat.
    #  Выхлоп / fat mat / после The и the

    i  # (insensitive) Поиск без учета регистра
    g  # Глобальный поиск: поиск шаблона во всем входном тексте
    m  # Мультистроковой поиск: Якоря применяются к каждой строке.

    #     The =V=> The fat cat sat on the mat =  Выхлоп/  The /
    # /The/gi =S=> The fat cat sat on the mat =  Выхлоп/ The the /

    # /.at(.)?$/   =V=> The fat\n cat sat\n on the mat =  Выхлоп/  mat /
    # /.at(.)?$/gm =S=> The fat\n cat sat\n on the mat =  Выхлоп/ fat sat mat /

    address = re.compile("""
            # Имя состоит из букв и может включать символы точки "."
            # В сокращенных вариантах обращения и инициалах
            ((?P<name>
                ([\w.,]+\s+)*[\w.,]+)
                \s*
                # Адреса электронной почты заключаются в угловые скобки
                # < >, но только если найдено имя, поэтому открывающая
                # Угловая скобка включена в эту группу
                <
            )? # Полное имя является необязательным элементом
            # Собственно электронный адрес: username@domain.tld
            (?P<email>
                [\w\d.+-]+ # Имя пользователя
                @
                ([\w\d.]+\.)+ # Префикс имени домена
                (com|org|edu) # Ограничение списка доменов верхнего уровня
            )
            >? # Необязательная закрывающая угловая скобка
        """, re.VERBOSE)
    address.search(' First M. Last <first.last@example.com>')
    # Выхлоп / Name : First M. Last
    #          Email: first.last@example.com /
    """
    pattern=r"\d+" # Пока символ является числом склеивать
    r"[A-Z]{5}" делит сообщение по 5 букв 
    <a href="https://stepic.org/porn.html">1</a>   
    r'<a[^>]*?href="(.*?)"[^>]*?>' — вытаскивает ссылку https://stepic.org/porn.html
    r'<a.*?href=".*?:\/\/((?:\w|-)+(?:\.(?:\w|-)+)+)' — вытаскивает stepic.org"""


# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class str_and_string():
    str_ = "это пример строки."

    """capitalize():
    Возвращает копию строки с преобразованием только первого символа в заглавную букв."""
    str_.capitalize()
    #  Выхлоп / 'Это пример строки.' /

    """Метод title()
    Возвращает копию строки в которой первые символы всех слов идут с заглавной буквы."""
    str_.title()  # Выхлоп / 'Это Пример Строки.' /
    # _____ or _____ #
    string.capwords(str_)  # Выхлоп / 'Это Пример Строки.' /

    """Метод zfill()
    Дополняет указанную строку нулями слева, до указанной минимальной длины."""
    str(12).zfill(7)  # Выхлоп / '001' /

    """Метод swapcase()
    Возвращает копию строки в которой все символы, основанные на регистре, поменялись местами"""
    'Кот ОбОрМот!'.swapcase()  # Выхлоп / 'кОТ оБоРмОТ!' /

    """Метод find() 
    Возвращает индекс первого вхождения одной строки в другую или -1
    ⚫ В отличие от index() не вызывает ошибки ValueError"""
    str_.find("?")  # Выхлоп / -1 /
    str_.startswith("Hi")  # Можем узнать начинается ли str с кортежа ("Hi","hello") или другой строки
    str_.endswith(".py")  # Можем узнать заканчивается ли str кортежем (".py","png") или другой строкой
    str_.rstrip('m')  # Убирает указанный символ в конце строки  str.rstrip() убирает все пробелы и /\n/ в конце строки
    str_.lstrip('m')  # Убирает указанный символ в начале строки
    str_.strip('m')  # Убирает указанный символ в конце и в начале строки

    """Метод replace(a,b,k=None): заменяет  a->b, k раз внутри str"""
    str_.replace(",", ", ", 5)

    # Мульти-замена
    "Swap vowels for numbers.".translate(str.maketrans('aeiou', '12345'))
    # Выхлоп /  `Sw1p v4w2ls f4r n5mb2rs.` /
    "Swap about.".translate({ord("a"): "b", ord("b"): "a"})
    # Выхлоп / `Swbp baout.` /

    """Метод split(sep=" ", maxsplit), возвращает список всех слов в строке, используя sep в качестве разделителя, при необходимости, можно ограничить число разделений."""
    str_.split()  # Выхлоп /  ['это', 'пример', 'строки.']  /
    str_.split('р', maxsplit=1)  # Выхлоп /  ['это п', 'имер строки.'] /


# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class list():
    list_ = ['физика', 'химия', 'математика'], obj = [], list = (), seq = [], index = []
    a = [i for i in range(31)]
    # Выхлоп / a = [0, 1, 2, 3, ... , 30]

    list.insert(index, obj), """ Вставляет объект obj в список по смещению индекса"""
    list_.insert(1, 'биология')
    #  Выхлоп / ['физика', 'биология', 'химия', 'математика'] /

    list.extend(seq), """ Объединяет 2 списка / всё равно, что (+)"""
    list_.extend([0, 1, 2, 3, 4])
    #  Выхлоп / ['физика', 'химия', 'математика', 0, 1, 2, 3, 4] /

    list.pop(obj), """ Удаляет и возвращает объект по индексу или последний из списка"""
    list_.pop(1)
    #  Выхлоп / 'химия' /

    list.remove(obj), """ Удаляет объект obj из списка на месте"""
    list_.remove('биология')

    list.reverse(), """ Изменяет объекты списка на месте."""
    list_.reverse()

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class set_dict():
    """
    Множества — это особый вид контейнеров, которые не являются ни последовательностями, ни отображениями.
                Они не могут индексироваться, но имеют размер (количество элементов) и являются итерируемыми.
                Кроме того, множества поддерживают ряд операций ( & , | , ^, - ), а также операции проверки принадлежности и сравнения) и эквивалентных им неспециальных методов (intersection, union и др.).
    Словарь – это ассоциативный массив, или таблица хешей, содержащий объекты, индексированные ключами.
            – это единственный встроенный тип, который является объектом отображений.
                Объекты отображений представляют произвольные коллекции объектов, которые могут индексироваться другими коллекциями практически произвольных ключей.
                В отличие от последовательностей, отображения являются неупорядоченными коллекциями и могут индексироваться числами, строками и другими объектами. Отображения относятся к разряду изменяемых коллекций.
             В качестве ключей словаря допускается использовать любые неизменяемые объекты (строки, числа, кортежи и так далее)
            ⚫ Порядок ключей в словарях гарантированно совпадает с порядком их вставки, это добавлено в спецификацию. (python 3.7)
    """

    """ Объединение двух словарей в один новый словарь """
    d1 = {"AAA": 30, "ZZZ": 30, }
    d2 = {"AAA": 31, "ZZZ": 30, }
    # ⚫ При пересечение ключей берётся значение из последнего словаря
    dict_ = {**d1, **d2}  # => {'AAA': 31, 'ZZZ': 30}

    """Найти общие ключи|значения в словарях"""
    d1.keys() & d2.keys()  # =>  {'AAA', 'ZZZ'} общие ключи
    d1.keys() - d2.keys()  # =>  set() ключи 1 словаря без ключей 2
    d1.items() & d2.items()  # =>  {('ZZZ', 30)} общие пары

    """ update() обновляет/дополняет словарь <смотри collections.ChainMap>,
     перезаписывая существующие ключи новыми значениями. Если ключ в словаре отсутствует, то он добавляется."""
    d1.update({"ZZZ": 31})  # {'AAA': 30, 'ZZZ': 0}
    d1.update([('BBB', 30), ('CCC', 30)])  # {'AAA': 30, 'ZZZ': 0, 'BBB': 30, 'CCC': 30}

    """ Создание нового словаря из старого без ключей "ZZZ", "XXX" """
    dict_ = {key: dict_[key] for key in dict_.keys() - {"ZZZ", "XXX"}}

    """ Найти max|min значение в словаре"""
    dict_ = {"key1": 30, "key2": 20, "key3": 10, }
    min(dict_, key=lambda key: dict_[key])  # => 'key3'
    max(zip(dict_.values(), dict_.keys()))  # => (30, 'key1')

    """ Отсортировать словарь по значениям """
    sorted(dict_.items(), key=lambda item: item[1])
    # Выхлоп / [('key3', 10), ('key2', 20), ('key1', 30)]/

    """Отсортировать список словарей по значению словаря  >смотри itemgetter<"""
    list_to_be_sorted = [{'name': 'Homer', 'age': 39}, {'name': 'Bart', 'age': 10}]
    sorted(list_to_be_sorted, key=lambda k: k['name'])  # По 1 ключу
    sorted(list_to_be_sorted, key=lambda k: (k['name'], k['age']))  # По 2м ключам
    # Выхлоп / [{'name': 'Bart', 'age': 10}, {'name': 'Homer', 'age': 39}]/

    import collections
    """defaultdict() - подкласс словаря
    ⚫ Попытка доступа к отсутствующему ключу его создаёт и инициализирует, используя принятую по умолчанию фабрику, то есть в данном примере list()"""
    dd = collections.defaultdict(list)
    dd['colors'] += ['red', 'green', 'blue']
    # Выхлоп / defaultdict(list, {'colors': ['red', 'green', 'blue']})/


# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class functools():
    """Модуль functools предоставляет функции и типы, поддерживающие функциональное программирование в python
    Предоставляемые модулем functools инструменты позволяют адаптировать или расширять функции и другие вызываемые объекты без полного их переписывания."""

    """Функция reduce(func, seq, init) поочередно применяет func к элементам последовательности seq в направлении слева направо, сводя ее к единственному значению.
    Функция reduce вызывает func для первого из двух элементов seq, затем для результата первого вызова и третьего элемента т.д.  
    Если задан аргумент init, то он используется до того, как будет использован первый элемент seq, если таковой имеется."""
    functools.reduce(operator.mul, range(1, 6), 1)  # Выхлоп / 120 /((((1*2)*3)*4)*5)

    """Функция partial(func, *a, **k) создает новую функцию, путем фиксирования части аргументов func"""
    def test(a, b, c, d): print(a, b, c, d)
    test1 = functools.partial(test, 1, 2, d=4)  # a = 1, b = 2, d =  4
    test1('Ого!')  # Выхлоп / 1 2 Ого! 4/

    """Декоратор мемоизации lru_cache(max_size=128, typed=False) обертывает функцию кешем LRU (least recently used)
    Если аргумент typed имеет значение True, то аргументы, которые при сравнении оказываются равными, но относятся к различным типам, например 23 и 23.0, кешируются по-отдельности."""
    @functools.lru_cache(maxsize=32)
    def test(a, b, /): return a ** 2 + b ** 2
    for x, y in zip([1, 2, 3, 1, 1], [1, 2, 3, 1, 1]): test(x, y)
    print(test.cache_info())  # Выхлоп / CacheInfo(hits=2, misses=3, maxsize=32, currsize=3) /

    """Декоратор класса total_ordering оборачивается вокруг класса, который предоставляет по крайней мере один метод, выполняющий проверку на неравенство, например lt, а также eq.
    Исходя из существующих методов класса класс декоратора total_ordering добавляет в него остальные методы, выполняющие проверку на неравенство, что избавляет от необходимости самостоятельно добавлять шаблонный код"""
    @functools.total_ordering
    class Integer():
        def __init__(self, number): self.number = int(number)
        def __eq__(self, other): return self.number == other.number
        def __lt__(self, other): return self.number < other.number
    Integer(1) >= Integer(2)  # Выхлоп / False /

    """Обобщенные функции: Декоратор singledispatch, обеспечивает регистрацию набора обобщенных функций c возможностью автоматического выбора нужной функции на основании типа первого аргумента"""
    @functools.singledispatch
    def myfunc(arg): print(f'default myfunc({arg.__repr__()})')
    @myfunc.register(list)
    def myfunc_list(arg): print(f'myfunc_list({arg})')
    myfunc("String arg")     # Выхлоп / default myfunc('String arg') /
    myfunc(['a', 'b', 'c'])  # Выхлоп / myfunc_list(['a', 'b', 'c']) /


# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class itertools():
    """
    Модуль itertools предлагает высокопроизводительные компоненты, предназначенные для создания итераторов и манипулирования ими.
    При обработке крупных совокупностей элементов во многих случаях следует отдавать предпочтение итераторам, а не, например, спискам.
    Это объясняется тем, что итераторы применяют подход, в котором используются так называемые "ленивые" (отложенные) вычисления:
      итератор возвращает с помощью ключевого слова yield по одному элементу за раз по мере необходимости, а не сразу все элементы в виде списка (или другого рода последовательности), который весь должен храниться в памяти.
    """
    """Функция chain(*iterables) возвращает элементы из первого аргумента, затем из второго и т.д """
    itertools.chain('ABC', 'DEF')  # Выхлоп / A B C D E F /

    """Функция zip_longest(*iterables, fillvalue) Возвращает кортежи, включающие по одному соответствующему элементу из каждого итерируемого объекта; 
    В отличие от стандартной функции zip вычисления прекращаются по исчерпании самого длинного итерируемого объекта."""
    itertools.zip_longest('ABCD', 'xy', fillvalue='-')  # Выхлоп / Ax By C- D- /

    """Функция count(start=0, step=1) создает итератор, возвращающий бесконечную последовательность целых чисел."""
    itertools.count(10)  # Выхлоп / 10 11 12 13 14 ... /

    """Функция cycle(iterable) возвращает каждый из элементов iterable, бесконечно повторяя элементы с самого начала """
    itertools.cycle('ABCD')  # Выхлоп / A B C D A B C D ... /

    """Функция repeat(item, times) повторно возвращает элемент item, times раз или бесконечно"""
    itertools.repeat(10, 3)  # Выхлоп / 10 10 10 /
    # Функцию repeat() удобно использовать совместно c функциями zip() и map(), если со значениями, возвращаемыми другими итераторами, должно сочетаться некое инвариантное значение.
    list(map(pow, range(10), itertools.repeat(3)))
    # Выхлоп / [0 1, 4, 9, 16, 25, 36, 49, 64, 81] / В данном случае итератор, возвращаемый функцией repeat(), не нуждается в явном ограничении числа повторений, поскольку обработка c помощью функции map() прекращается сразу же, как только исчерпывается любой из ее входных итераторов.

    """Функция compress(data, condition) возвращает каждый элемент data, которому в conditions соответствует элемент с истинным значением"""
    itertools.compress('ABCDEF'[1, 0, 1, 0, 1, 1])  # Выхлоп / A C E F /

    """Функция filterfalse(func, iterable) Возвращает те элементы итерируемого объекта, для которых func возвращает значение False"""

    """Функция dropwhile(func, iterable) начинает возвращать все оставшиеся элементы как только условие принимает ложное значение"""
    itertools.dropwhile(lambda x: x < 5, [1, 4, 6, 4, 1])  # Выхлоп / 6 4 1 /

    """Функция takewhile(func, iterable) прекращает возвращать элементы, как только условие принимает ложное значение """
    itertools.takewhile(lambda x: x < 5, [1, 4, 6, 4, 1])  # Выхлоп / 1 4 /

    """Функция groupby(iterable, key) сканирует последовательность и ищет последовательные одинаковые значения. В каждой итерации возвращает значение вместе с группой.
    ⚫ Нужно сортировать данные по нужному нам полю, т.к groupby проверяет только последовательные элементы"""
    # Группировка по значению конкретного поля
    data = [{'name': 'Artem', 'age': 39}, {'name': 'William', 'age': 40}, {'name': 'Jack ', 'age': 39}, {'name': 'Amelia', 'age': 40}]
    data.sort(key=operator.itemgetter('age'))
    itertools.groupby(data, key=operator.itemgetter('age'))
    # Выхлоп / [(39, <itertools._grouper>), (40, <itertools._grouper>)] /

    """Функция accumulate(iterable, func, initial) в отличие от functools.reduce() возвращает промежуточные результаты"""
    itertools.accumulate(range(1, 6), operator.mul)  # Выхлоп / 1, 2, 6, 24, 120 /

    """Функция product(*iterables, repeat=1) возвращает декартово произведение входных итерируемых последовательностей."""
    itertools.product('ABCD', '123')    # Выхлоп / A1 A2 A3 B1 B2 B3 C1 C2 C3 D1 D2 D3/
    itertools.product('ABCD', repeat=2) # Выхлоп / AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD /

    """Функция permutations(iterable, r=len(iterable)) возвращает все возможные перестановки заданной длины.
    Количество возвращенных сочетаний равно n! / (n-r)! если 0 <= r <= n или ноль если r > n.
    Перестановки выводятся в лексикографическом порядке сортировки. Таким образом, если входная последовательность отсортирована, то кортежи перестановок будут созданы в отсортированном порядке."""
    itertools.permutations('ABCD', 2)  # Выхлоп / AB AC AD BA BC BD CA CB CD DA DB DC/

    """Функция permutations(iterable, r=len(iterable)) возвращает все возможные комбинации элементов заданной длины.
    Количество возвращенных сочетаний равно n! / (r!(n-r)!) если 0 <= r <= n или ноль если r > n."""
    itertools.combinations('ABCD', 2)  # Выхлоп / AB AC AD BC BD CD /

    """Функция combinations_with_replacement(iterable, r=len(iterable)) возвращает все возможные комбинации элементов заданной длины, позволяя повторять в комбинациях отдельные элементы более одного раза.
    Количество возвращенных сочетаний равно (n+r-1)! / (r!(n-1)!) если n > 0."""
    itertools.combinations_with_replacement('ABCD', 2)  # Выхлоп / AA AB AC AD BB BC BD CC CD DD /


# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class TryExcept():
    try:  ...
    except (TypeError,ValueError)  as e:  """ except ValueError: выводит ошибку если введён  не тот тип, TypeError"""
        print("Error! Print only INT numbers!")  ,
        print(e.args)
    except: continue  # Перенаправляет (игнорирует) ошибки
    finally: ... # Выполнится всегда
    else: ... # Выполнится, если ошибки не произошло


    """ Повторное возбуждение исключения"""
    try: ...
    except Exception  as e:
        print("У нас проблемы")
        raise

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class operator():
    """Модуль operator предоставляет две высокоуровневые функции. Их возвращаемыми результатами являются функции, которые можно передавать в качестве именованного аргумента key= методу sort списков, встроенной функции sorted, функции itertools.groupby() и другим встроенным функциям, таким как min и max."""

    """Функция attrgetter(attr) возвращает вызываемый объект f, такой, что f(о) - это то же самое, что getattr(о, attr). 
    Строка attr может включать точки (.), и в этом случае результат функции attrgetter повторно вызывает функцию getattr. 
    Например, attrgetter('а.Ь') эквивалентно lambda o: getattr(getattr(o, 'а'), 'Ь')."""
    itertools.groupby(points, operator.attrgetter('x'))

    """Функция itemgetter(attr) возвращает вызываемый объект f, такой, что f(о) - это то же самое, что getitem(o, key). 
    Если функция attrgetter вызвана с несколькими аргументами, то результирующий вызываемый объект извлекает каждый из элементов, определяемых ключами, и возвращает результирующий кортеж значений.
    Предположим, что имеется список списков L, в котором каждый подсписок содержит по крайней мере три элемента:
    нужно отсортировать L на месте по третьему элементу каждого подсписка, причем подсписки, в которых третьи элементы равны, сортируются по их первым элементам."""
    L = [(2, 0, 3), (1, 0, 3), (10, 0, 1), (20, 0, 1)]
    L.sort(key=operator.itemgetter(2, 0))  # Выхлоп / [(10, 0, 1), (20, 0, 1), (1, 0, 3), (2, 0, 3)]/


# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class oop():
    class Date:
        _formats = {
            'ymd': '{d.year}—{d.month}—{d.day}',
            'mdy': '{d.month}/{d.day}/{d.year}',
            'dmy': '{d.day}/{d.month}/{d.year}',
        }
        __slots__ = __ = ['year', 'month', 'day']

        def __init__(self, year, month, day):
            self.year = year
            self.month = month
            self.day = day

        def __repr__(self):
            return "Date({d.year!r}, {d.month!r}, {d.day!r})".format(d=self)

        def __str__(self):
            return "{0.year!s}/{0.month!s}/{0.day!s}".format(self)

        def __format__(self, code='ymd'):
            fmt = self._formats[code]
            return fmt.format(d=self)

    # -------------------- Пример менеджера контекста
    class Service():
        handle_error = True

        def __init__(self):
            self.session = requests.Session()

        def __enter__(self):
            print('Выполнился метод __enter__')
            return self.session

        def __exit__(self, exc_type, exc_value, exc_traceback):
            print('Выполнился метод __exit__')
            self.session.close()
            if exc_type is not None:
                print(f'Класс исключения: {exc_type}',
                      f'Текст ошибки: {exc_value}',
                      f'Текстовый вид исключения: {traceback.format_tb(exc_traceback)}', sep='\n\n')
            return self.handle_error

    with Service() as session:
        response = session.get('http://api.stackexchange.com/2.2/info?site=stackoverflow')
        raise ValueError("Возникла тестовая ошибка")
    """ Выхлоп /
    1. Выполнился метод __enter__
    2. Выполнилось тело with.
    3. Выполнился метод __exit__
        Класс исключения:
            <class 'ValueError'>
        Текст ошибки:
            Возникла тестовая ошибка
        Текстовый вид исключения: 
            Traceback (most recent call last):
            File C:/Users/admin/Desktop/test.py, line 30, in <module>
            raise ValueError("Возникла тестовая ошибка")
            ValueError: Возникла тестовая ошибка 
    4. Выполнился метод __del__"""

    """───────────────────────────┐ Универсальные специальные методы и атрибуты ┌───────────────────────────────────────
    
    __init__(self)
                Основным назначением конструктора __init__ является создание атрибутов нового экземпляра класса.  
                ⚫ Метод __init__ не должен возвращать значение, отличное от None.
                
    __new__(C, *a, **k)
                Каждый класс содержит (или наследует) метод __new__. Каждый раз, когда создается новый экземпляр класса С посредством вызова С(*а, **k), сначала автоматически вызывается метод С.__new__(С, *а, **k).
                Возвращаемое методом __new__ значение x используется в качестве вновь созданного экземпляра.
                Затем Python вызывает метод С.__init__(х, *a, **k), но только в том случае, если х действительно является экземпляром класса С или любого из его подклассов (в противном случае х будет находиться в том состоянии, в каком его оставил метод __new__). 
                         
    Методы перегрузки операций, такие как __str__ и __add__, перехватывают и снабжают поведением встроенные операции, которые применяются к экземплярам классов, включая вывод, операции выражений и т.д.
    Они запускаются автоматически в ответ на встроенные операции и предоставляют классам возможность соответствовать ожидаемым интерфейсам.

    __repr__(self) Возвращает кодовое представление класса
               Обычно возвращаемая строка представляет собой такое выражение, что eval(repr(х)) == х или полезное текстовое представление, заключенное между < и >
               Примеры: >>> open('test.txt')
                        Выхлоп / <_io.TextIOWrapper name='test.txt' mode='r' encoding='cp1251'> /
                        >>> Date(2021, 12, 21)
                        Выхлоп / Date(2021, 12, 21) /

    __str__(self) Возвращает неформальное компактное строковое представление класса. Вызывается функциями str и print.
               ⚫ Если __str__ отсутствует, используется вывод __repr__
               Пример: >>> print(Date(2021, 12, 21))
               Выхлоп / '2021/12/21' /

    __format__(self, format_string) 
              Включает кастомное форматирование через функцию format и строковый метод
              Пример: >>> 'The date is {d:mdy}'.format(d=Date(2021, 12, 21))
                     Выхлоп / 'The date is 12/21/2021' /
    
    __enter__(self), __exit__(self, exc_type, exc_value, exc_traceback)                         
              Эти методы позволяют реализовать объекты, совместимые инструкцией with.
              Результат метода __enter__ помещается в переменную, указанную с помощью квалификатора as.
              Очищающий код в методе __exit__ выполнится в любом случае. Если  __exit__ возвращает True, то исключения в блоке with игнорируется.
    
    Методы перехвата доступа к атрибутам — это специальная категория методов перегрузки операций, кторая предлагает способ перехвата доступа к атрибутам экземпляров через __getattr__ , __setattr__, __delattr__ и __getattribute__ 
    позволяют классам оболочек (т.е. посредникам) вставлять автоматически запускаемый код, который может проверять допустимость запросов атрибутов и делегировать их внутренним объектам.
    В отличие от дескрипторов их следует определять для объекта, содержащего атрибуты и вызываются они при доступе к любому атрибуту этого объекта.

    __getattr__(self, name)
              Этот метод будет вызван в случае, если запрашиваемый атрибут не найден обычным механизмом (в __dict__ экземпляра, класса и т.д.), что обычно приводит к возникновению исключения AttributeError.
    
    __getattribute__(self, name)
              Этот метод вызывается при каждой попытке получить значение атрибута. Перекрытие этого метода замедляет доступ к атрибутам, 
    
    Специальные атрибуты, такие как __class__ и __dict__, позволяют просматривать внутренние детали реализации объектов с целью их обобщенной обработки — для получения списка всех атрибутов объекта, отображения имени класса и т.д.

    __slots__ Путем добавления атрибута __slots__ в определение класса уменьшает потребление памяти за счет более компактного представления экземпляров.
              Вместо снабжения каждого словарем они создаются на базе небольшого массива фиксированного размера.
              Нужно использлвать слоты только в классах, которые служат структурами данных.
              ⚫ Без переменной словаря __dict__, экземплярам нельзя назначить новые переменные/атрибуты, не указанные в __slots__. 
              ⚫ Дочерние подклассы получат __dict__, если они не определят __slots__ (который должен содержать только имена любых дополнительных слотов).
              
    __mro__  Если пытаться сослаться на атрибут С.attr класса C и строка 'attr' не является ключом в словаре С.__dict__, то процедура поиска переходит к просмотру 
             объектов каждого из классов, встречающихся в атрибуте C.__bases__, в определенном порядке (который по историческим причинам носит название порядок разрешения методов, или MRO (Method Resolution Order),
             но применяется ко всем атрибутам, а не только к методам). В свою очередь, базовые классы класса C могут иметь собственные базовые классы. Процедура поиска поочередно просматривает прямых и косвенных предков в соответствии с MRO и останавливается, когда находит требуемое имя."""
    # -------------------- Пример реализации контейнера, в котором элементы хранятся в отсортированном порядке
    class SortedItems(collections.abc.Sequence):
        def __init__(self, initial=None):
            if initial is not None:
                self._items = sorted(initial)
            else:
                self._items = []

        def __getitem__(self, index):
            return self._items[index]

        def __len__(self):
            return len(self._items)

        def add(self, item):
            bisect.insort(self._items, item)
    items = SortedItems([19, 2, 5])
    items.add(23)  # Выхлоп /[2, 5, 19, 23]/
    """                   ┌─────────────────────┬────────────┬───────────────────────┐   
                          │    Категория типов  │  Имя типа  │      Описание         │
                          │                     │            │                       │
                          │ Последовательности  │ str        │ Строки символов       │
                          │                     │ list       │ Списки                │
                          │                     │ tuple      │ Кортежи               │
                          │                     │ range      │ Диапазоны целых чисел │
                          │                     │            │                       │
                          │ Отображения         │ dict       │ Словари               │
                          │ Множества           │ set        │ Изменяемые множества  │
                          │                     │ frozenset  │ Неизменяемые множества│
                          │     ┌───────────────┴────────────┴─────────────────┐     │ 
    ──────────────────────┴─────┴────────┐ Специальные методы контейнеров ┌────┴─────┴──────────────────────────────────
    
    __contains__(self, item) 
                Булева операция у in х вызывает метод х.__contains__(у).
                Если метод __contains__ отсутствует, то Pythoп выполняет операцию у in х, затрачивая на это время, пропорциональное len(х), следующим образом: for z in х: if y==z: return True
    
    __delitem__(self, key)
                Вызывается в ответ на запрос открепления элемента или среза контейнера х (обычно посредством выполнения операции del х[key]).

    __getitem__(self, key)
                Вызывается при попытке доступа к элементам с использованием выражения х[key] (т.е. при попытке получения элементов с помощью индекса или среза контейнера х) 
                ⚫ Все контейнеры, за исключением подобных множествам, должны иметь этот метод.
                 
    __iter__(self)
                Вызывается в ответ на запрос выполнения цикла по всем элементам х (for item in х)
                Встроенная функция iter(х) также вызывает этот метод.
                Если метод __iter__ отсутствует, то функция iter(х) возвращает объект итератора, который обертывает х и вырабатывает значения х[О] , х[1] и т.д. до тех пор, пока при попытке получения одного из этих индексированных элементов не возникнет исключение IndexError
                Лучше предусматривать метод __iter__ для каждого создаваемого контейнера.
                
    __setitem__ (sеlf, key, value)
                Вызывается в ответ на запрос связывания элемента или среза х (х[key]=value) 
                Контейнер должен иметь этот метод только в том случае, если х — изменяемый объект."""
    # -------------------- Пример использования property
    class Person:
        def __init__(self, first_name, last_name, age):
            self.first_name = first_name
            self.last_name = last_name
            self.age = age

        @property
        def age(self):
            return self.__age

        @age.setter
        def age(self, value):
            if not isinstance(value, int):
                raise TypeError('Expected a int')
            if value <= 0:
                raise ValueError('Age is not valid')
            self.__age = value

        @property
        def full_name(self):
            return f"{self.first_name} {self.last_name}"

    # -------------------- Пример расширения свойства в подклассе
    class SubPerson(Person):
        @Person.age.getter
        def age(self):
            print('Getting age')
            return super().age
    """ Про создание управляемых атрибутов:
    Простой способ кастомизировать доступ к атрибуту заключается в определении свойства (property)
    Свойство — это на самом деле коллекция связанных вместе методов (fget, fset, fdel).
    Свойства также могут быть отличным способом определить вычисляемые атрибуты (в примере это full_name)
    Примечание: Не надо часто повторять определения свойств, т.к это приводит к повторению кода, лучше использовать дескрипторы или замыкания"""

    # ------------------ Пример дескриптора, выполняющего проверку типа при присваивании значения атрибуту
    class TypedProperty:
        def __init__(self, name, expected_type):
            self.name = name
            self.expected_type = expected_type

        def __get__(self, instance, cls):
            """ Params:
                • self — экземпляр класса TypedProperty
                • instance — экземпляр класса Person
                • cls — класс Person
            """
            if instance is None:
                return self
            else:
                return instance.__dict__[self.name]

        def __set__(self, instance, value):
            if not isinstance(value, self.expected_type):
                raise TypeError(f"Значение должно быть типа {self.expected_type}")
            instance.__dict__[self.name] = value

    def typeassert(**kwargs):
        def decorate(cls):
            for name, expected_type in kwargs.items():
                setattr(cls, name, TypedProperty(name, expected_type))
            return cls
        return decorate

    # -------------------- Пример использования декоратора класса с дескриптором
    @typeassert(first_name=str, last_name=str, age=int)
    class Person:
        # Пример использования класса дескриптора без декоратора
        user_id = TypedProperty('user_id', int)

        def __init__(self, first_name, last_name, age):
            self.first_name = first_name
            self.last_name = last_name
            self.age = age
    user = Person("Mike", "Driscoll", 23)
    user.user_id = 'id:321312'  # Выхлоп / TypeError: Значение должно быть типа <class 'int'> /
    """Дескрипторы атрибутов классов
    Дескриптор — это обычный объект, представляющий значение атрибута. За счет реализации одного или более специальных методов __get__(), __set__() и __delete__() он может подменять механизмы доступа к атрибутам и влиять на выполнение этих операций.
    Путем определения дескриптора можно перехватывать базовые операции экземпляров на более низком уровне.
    ⚫ Дескрипторы могут быть определены только на уровне класса, но не на уровне экземпляра
       Кроме того, имя атрибута, используемое для сохранения дескриптора в классе, имеет более высокий приоритет перед другими атрибутами на уровне экземпляров 
    Примечание: не стоит писать дескриптор для кастомизации доступа к одному атрибуту конкретного класса. 
    """

# ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
class cook():
    from collections import deque
    # Создаёт последовательность с максимальной длиной 3
    history = deque(maxlen=3)
    # [1, 2, 3] + [4] => [2, 3, 4]

    """ Использование ChainMap + argparse. <смотри dict.update()> ChainMap() группирует несколько словарей"""
    from collections import ChainMap
    defaults = {'ip': 'localhost', 'port': 7777}
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '—ip')
    parser.add_argument('-p', '—port')

    args = parser.parse_args()  # Возвращает Namespace(ip=None, port=None)
    new_dict = {key: value for key, value in vars(args).items() if
                value}  # vars() возвращает словарь пространства имен объекта
    # Поиск ключей в ChainMap() происходит последовательно, слева на право, во всех добавленных словарях, пока не будет найден соответствующий ключ
    settings = ChainMap(new_dict, defaults)

    """ Сounter помогает найти количество повторений"""
    words = ['spam', 'egg', 'spam', 'counter', 'counter', 'counter']
    word_count = collections.Counter()
    for word in words: word_count[word] += 1
    # Выхлоп / word_count = Counter({'counter': 3, 'spam': 2, 'egg': 1})

    word_count = collections.Counter(words)
    print(word_count.most_common(2))
    # Выхлоп / {'counter': 3, 'spam': 2} /

    collections.Counter('abracadabra').most_common(3)
    # Выхлоп / [('a', 5), ('r', 2), ('b', 2)] /

    import heapq
    arr = [1, 2, 3, 123, 111, 234]
    print(heapq.nlargest(3, arr)) # [234, 123, 111]
    print(heapq.nsmallest(3, arr))# [1, 2, 3]

    heapq.heapify(arr)  # Сортировка
    print(arr[0], arr[-1])  # min и max значения
    heapq.heappush(arr, 2)  # Добавление
    print(heapq.heappop(arr))  # Возвращает min элемент, удаляет его

    heapq.heappush(queue, (priotiry, index, item))  # Добавление в очередь с приоритетом
    heapq.heappop(queue)[-1]  # Удаление из очереди

    """Группировка по значению конкретного поля"""
    import collections
    data = [{'name': 'Artem', 'age': 39}, {'name': 'William', 'age': 40},
            {'name': 'Jack ', 'age': 39}, {'name': 'Amelia', 'age': 40}]
    group_by_age = collections.defaultdict(list)
    for row in data: group_by_age[row["a"]].append(row)
    # {39: [{'name': 'Artem', 'age': 39}, {'name': 'Jack ', 'age': 39}],
    #  40: [{'name': 'William', 'age': 40}, {'name': 'Amelia', 'age': 40}]}

    """ Вернуть все возможные перестановки массива """
    import itertools
    arr = [1, 2, 3]
    pr = [i for i in itertools.permutations(arr, 2)]


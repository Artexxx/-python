"""
Классическая задача жадного алгоритма: интервальное планирование.

Эта проблема широко используется в нашей повседневной жизни.
Например, сегодня вы получаете несколько видов деятельности,
 каждая из которых может быть представлена временем ее начала и временем окончания с интервалом [start, end].
Очевидно, что вы не можете посещать 2 мероприятия одновременно,
 поэтому эта проблема может быть изменена на вопрос о том, как найти максимальные подмножества
 без какого-либо временного перекрытия.
"""

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| Подсчёт непересекающихся интервалов |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

"""
Задача:
  Учитывая ряд замкнутых интервалов [start, end], вы должны написать
  алгоритм для вычисления максимального числа подмножеств без какого-либо перекрытия.

Пример:
  intvs = [[1,3], [2,4], [3,6]], набор интервалов имеет не более 2x подмножеств без
  какого-либо перекрытия [[1,3], [3,6]], поэтому ваш алгоритм должен возвращать 2 в качестве результата.

Алгоритм:
  0. Сортируем интервалы по их концу.
  1. Выбираем интервал X, который имеет самое раннее время окончания среди всех текущих интервалов, из набора интервалов intvs.
  2. Пропускаем все инверталы, пересекающиеся с X, если инвертал не пересекает X, записываем его в X
"""


def countIntersectionInterval(intervals):
    """
    Возращает максимальное число интервалов без какого-либо перекрытия.

    >>> intervalSchedule([[1, 3], [2, 4], [3, 6]]
    2
    """
    if not intervals: return 0
    intervals = sorted(intervals, key=lambda x: x[1])
    # по крайней мере, имеется один интервал без пересечения
    count = 1
    x_end = intervals[0][1]
    for interval in intervals:
        start = interval[0]
        if (start >= x_end):
            count += 1
            x_end = interval[1]
    return count


if __name__ == '__main__':
    print(countIntersectionInterval([[1, 3], [2, 4], [3, 6]]))
    print(countIntersectionInterval([[1, 5], [2, 4], [3, 6], [4, 7], [9, 11], [5, 12]]))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| Удаление пересекающихся интервалов |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

"""
Задача:
  Учитывая ряд замкнутых интервалов [start, end], найдите минимальное количество интервалов,
  которые необходимо удалить,чтобы остальные интервалы, без какого-либо перекрытия.

Пример:
  intvs = [[1,2],[1,2],[1,2]], набор интервалов имеет 3 подмножества с пересечением,
  надо удалить два [1,2], поэтому ваш алгоритм должен возвращать 2 в качестве результата.

Алгоритм:
  0. Сортируем интервалы по их концу.
  1. Выбираем интервал X, который имеет самое раннее время окончания среди всех текущих интервалов, из набора интервалов intvs.
  2. Удаляем все инверталы, пересекающиеся с X, если инвертал не пересекает X, записываем его в X
"""


def eraseOverlapIntervals(intervals):
    """
    Возращает минимальное количество  интервалов, которые надо удалить, чтобы остались интервалы без какого-либо перекрытия.

    >>> intervalSchedule([[1,2],[1,2],[1,2]]]
    2
    """
    if not intervals: return 0
    intervals = sorted(intervals, key=lambda x: x[1])
    count_remove = 0
    x_end = intervals[0][1]
    for interval in intervals:
        start = interval[0]
        if (start < x_end):
            count_remove += 1
        else:
            x_end = interval[1]
    return count_remove


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| Минимальное количество стрел для взрыва воздушных шаров |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

"""
Существует несколько сферических шаров, разбросанных в двумерном пространстве.
Для каждого баллона входными данными являются начальные и конечные координаты горизонтального диаметра.
Поскольку он горизонтален, координаты Y не имеют значения, и, следовательно, достаточно координат начала и конца диаметра.
Начало всегда меньше конца.Стрела может быть выпущена точно вертикально из разных точек вдоль оси X.
Воздушный шар с x_start и x_end лопается стрелой, выпущенной в x, если x_start ≤ x ≤ x_end.
Количество стрел, которые могут быть выпущены, не ограничено.
Стрела, однажды пущенная, продолжает двигаться вверх бесконечно.

Задача:
  Найдите минимальное количество стрел, которые необходимо выстрелить, чтобы лопнуть все воздушные шары.

Пример:
  balloons = [[1,2],[1,2],[1,2]], набор интервалов имеет 3 подмножества с пересечением,
  надо выпустить всего одну стрелу, поэтому ваш алгоритм должен возвращать 1 в качестве результата.

Алгоритм:
  0. Сортируем интервалы по их концу.
  1. Выбираем интервал X, который имеет самое раннее время окончания среди всех текущих интервалов, из набора интервалов intvs.
  2. Пропускаем все инверталы, пересекающиеся с X, если инвертал не пересекает X, записываем его в X
"""


def findMinArrowShots(intervals):
    if not intervals: return 0
    intervals = sorted(intervals, key=lambda x: x[1])
    count = 0
    x_end = intervals[0][1]
    for interval in intervals:
        start = interval[0]
        if (start > x_end):
            count += 1
            x_end = interval[1]
    return count


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| Минимальное количество такси |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

"""
Вы работаете в Центральном такси.Люди связываются с вами, чтобы заказать такси.
Они сообщают вам о времени, когда они хотят, чтобы их забрали и высадили.
Такси доступно для обслуживания нового клиента через 1 единицу времени после того, как оно высадило предыдущего клиента.
[*] Входной список не сортируется.
Задача:
    Какое минимальное количество такси вам нужно для обслуживания всех запросов?
Пример:
  balloons =[(1,4), (2, 9), (3, 6)], набор интервалов имеет 3 подмножества с пересечением,
  надо три такси, поэтому ваш алгоритм должен возвращать 3 в качестве результата.
"""
import numpy as np
def min_num_taxis(requests):
    """
    >>>min_num_taxis([(1,4), (2, 9), (3, 6), (5, 8)])
    3
    [-] Если интервал будут больше 100000, то алгоритм не сработает
    """
    zeros = np.zeros(100000)
    for r in requests:
        zeros[r[0]:r[1] + 1] += 1
    return max(zeros)


def min_num_taxis_opt(requests):
    """
    >>>min_num_taxis([(1,4), (2, 9), (3, 6), (5, 8)])
    3
    """
    pickup = sorted([i[0] for i in requests])  # время посадки
    dropoff = sorted([i[1] for i in requests])  # время высадки (+1 ; доступно через один час)
    taxinum = 0
    for ii in pickup:
        if ii > dropoff[0]:  # если время высадки прошло
            del dropoff[0]  # наименьшее значение
        else:
            taxinum += 1
    return taxinum

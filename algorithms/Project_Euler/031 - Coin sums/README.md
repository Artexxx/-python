# [Суммы монет](TODO)

## [Проблема](https://euler.jakumo.org/problems/view/31.html)

> В Англии валютой являются фунты стерлингов £ и пенсы p, и в обращении есть восемь монет:
>
>1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) и £2 (200p)
>
>£2 возможно составить следующим образом:
>
>1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
>
>Сколькими разными способами можно составить £2, используя любое количество монет?


``` python
solution   (100)  # => 4563
solution   (200)  # => 73682
```

### Примечание 1

Например, для N=4, S={1,2,3}. Есть четыре решения:{1,1,1,1} {1,1,2} {2,2} {1,3}
<br>где N - номинал собираемой монеты, S - виды монет

## Частное решение (1)

#### Рекурсивная формулировка

```  
N = 11 и COINS = {1,2,5}

       ___(11)___
     1/    2|     \5
   (10)    (8)    (6)
 1/ 2| \5  ...  1/ 2| \5
(9) (8) (5)   (5) (4)  (1)
  ...           1/ 2|\5
               (3)(2)(-1)
                  ...
```             

Мы пытаемся подсчитать количество различных множеств.

Множество решений **C(N, m)**, можно разбить на два множества:

1. Множество, которое не содержит ни одну монету вида **S_m**
2. Множество, которое содержит не менее 1 монеты вида **S_m**

Если сдача не содержит **S_m** (Из **N** при вычитании **S_m** получается отрицательное число), то мы можем оставить сдачу **N** без изменений,  таким образом мы сейчас решаем подзадачу c  **N**, **S={S_1,S_2, ... ,S_(m-1)** или **C(N,m-1)**

Если сдача содержит **S_m**  (Из **N** при вычитании **S_m** получается положительное число), то мы используем одну монету вида **S_m** и вычитаем её из предыдущей сдачи **N**,
 таким образом мы сейчас решаем подзадачу c  **N-S_m**, **S={S_1,S_2, ... ,S_(m)**. Это C(N-S_m, m).

Таким образом, мы можем сформулировать следующее:

**C(N,m)=C(N,m-1)+C(N-S_m,m)**

__Базовые случаями:__

- C(N,m)=1,N=0 (одно решение - у нас нет денег, точно один способ решить эту проблему-не выбирать монету без сдачи, или, точнее, выбрать монету со сдачей 0)
- C(N,m)=0,N<0 (нет решения - отрицательная сумма денег)
- C(N,m)=0,N>1,m<= 0 (нет решения - у нас есть деньги, но нет доступных изменений)

```python
def solution(N, S):
    def C(n, m):
        if n < 0 or m <= 0:
            return 0
        if n == 0:
            return 1
        return C(n, m - 1) + C(n - S[m-1], m)
    return C(N, len(S))
```

### Примечание 2

Рекурсивный подход называется *"сверху вниз"*, а динамическое программирование — *"снизу вверх"*

Что такое  *"сверху вниз"*? 
<br>
```
         f(20)
       /       \
   f(19)       f(18)
   /  \         /  \
f(17) f(18)  f(17) f(16)
```
Рекурсивное дерево, которое можно построить, идет сверху вниз от большой начальной задачи, такой как `f(20)`, 
и постепенно разбивает её до `f(1)` и `f(2)` тех пор, пока не достигнет дна, а затем возвращает ответ слой за слоем.

Что такое *"снизу вверх"*? 
```
f(1) f(2) f(3) ... f(18) f(19) f(20)
 1    1    2       2584  4181  6765
```
<br>В свою очередь, мы начинаем непосредственно с самого низа, самой простой, самой маленькой проблемы,`f(1)` и `f(2)`,
и мы толкаем ее вверх, пока не получим желаемый ответ `f(20)`, и это идея динамического программирования, 
и именно поэтому динамическое программирование обычно делается без рекурсии, путем итерации.

## Частное решение (1)

#### Динамическое програмирование

```python
def solution():
    ways = [1] + [0] * n

    for coin in coins:
        for i in range(coin, n + 1):
            ways[i] += ways[i - coin]
        print(ways)
    return ways[n]
```

## Похожая задача (1)

> Предположим, у нас есть монеты разного достоинства и общая сумма денег.
>
> Мы должны определить одну функцию, чтобы вычислить наименьшее количество монет, которое нам нужно, чтобы составить эту сумму.
>
> Когда эта сумма денег не может быть удовлетворена какой-либо комбинацией монет, верните -1.
> Таким образом, если вход равен [1,2,5], а сумма равна 11, то выход равен 3.
>
> Это получается с помощью 5 + 5 + 1 = 11.
>

``` python
solution   ( [1,2,5], 11)  # => 3 =  5 + 5 + 1 
solution   ([1,2,5, 200], 200)  # => 1 =  200
```

#### Динамическое програмирование

```python
def solution(amount=11, coins=[1,2,5]):
   if amount == 0: return 0
    if min(coins) > amount: return -1
    dp = [-1 for _ in range(0, amount + 1)]
    for i in coins:
        if i > len(dp) - 1:
            continue
        dp[i] = 1
        for j in range(i + 1, amount + 1):
            if dp[j - i] == -1:
                continue
            elif dp[j] == -1:
                dp[j] = dp[j - i] + 1
            else:
                dp[j] = min(dp[j], dp[j - i] + 1)
    # print(dp)
    return dp[amount]
```
"""\
Задача E1. Прогулка по мостам

Возможно вы знаете историю про то, как Эйлер гулял по мостам Кёнигсберга. Допустим теперь, что Эйлер попал на некий архипелаг, между некоторыми островами которого имеются мосты. Мосты построены таким образом, что между любыми двумя островами архипелага можно построить путь по этим мостам, причем этот путь единственный. Все острова пронумерованы от 11 до nn. Эйлер находится на острове номер 11 и желает совершить следующую прогулку: с острова номер 11 он хочет дойти до острова номер 22, далее до острова номер 33 и так далее до острова номер nn. С него он хочет вернуться на  остров номер 11. Он прекрасно понимает, что при этом ему придётся посещать некоторые мосты по многу раз. Осталось выяснить, сколько раз суммарно он пройдет по мостам во время своей прогулки.

Формат входных данных

В первой строке содержится число nn - количество островов в архипелаге, 2 \leq n \leq 10^32≤n≤10
3
 . В следующих n-1n−1 строках содержатся по два числа a_ia
i
​
  и b_ib
i
​
  через пробел - номера островов, соединённых мостом, 1 \leq a_i, b_i \leq n, a_i \neq b_i1≤a
i
​
 ,b
i
​
 ≤n,a
i
​


=b
i
​
 . Гарантируется, что между любыми двумя островами архипелага можно построить путь по этим мостам, причем этот путь единственный.

Формат выходных данных

Вывести длину описанного пути, то есть суммарное количество пересечений мостов, которые придётся совершить.

Пояснение к примеру



На рисунке вы видите расположение мостов в архипелаге из примера. Прогулка Эйлера будет проходить следующим образом:
1 - 5 - 8 - 2  : 3 моста

2 - 8 - 5 - 1 - 3  :  4 моста

3 - 1 - 5 - 4  :  3 моста

4 - 5  :  1 мост

5 - 8 - 6  :  2 моста

6 - 8 - 5 - 7  :  3 моста

7 - 5 - 8  :  2 моста

8 - 5 - 1  :  2 моста.

Итого он пройдет через 3 + 4 + 3 + 1 + 2 + 3 + 2 + 2 = 20 мостов.

Sample Input:

8
5 8
1 3
8 6
7 5
2 8
1 5
4 5
Sample Output:

20



#include <iostream>
#include <vector>
#include <fstream>
using namespace std;

long long depth_max = 99999999;
vector<vector<long long>> sp(0);

void dfs(long long v, long long x, vector<bool> chek, long long depth = 0) {
    chek[v] = true;
    if (depth < depth_max && v == x) {
        depth_max = depth;
    }
    for (int i = 0; i < sp[v].size(); i++) {
        long long to = sp[v][i];
        if (!chek[i] && to == 1) {
            dfs(i, x, chek, depth + 1);
        }
    }
}

int main() {
    long long n, m, sumx = 0, x, y;
    cin >> n;
    vector<bool> chek(n, false);
    sp.resize(n, vector<long long>(n, 0));
    m = n;
    for (int i = 0; i < m - 1; ++i) {
        cin >> x;
        cin >> y;
        sp[x - 1][y - 1] = 1;
        sp[y - 1][x - 1] = 1;
    }
    for (int i = 1; i < n; ++i) {
        depth_max = 99999999;
        dfs(i - 1, i, chek);
        sumx += depth_max;
    }
    depth_max = 99999999;
    dfs(n - 1, 0, chek);
    sumx += depth_max;
    cout << sumx << endl;
}
"""

"""
Данный шаг отличается от предыдущего формулировкой ограничений на входные данные. Перед проверкой решения задачи с формулировкой ограничений из этого шага, убедитесь, что это решение проходит и на предыдущем шаге.

Задача E2. Прогулка по мостам

Возможно вы знаете историю про то, как Эйлер гулял по мостам Кёнигсберга. Допустим теперь, что Эйлер попал на некий архипелаг, между некоторыми островами которого имеются мосты. Мосты построены таким образом, что между любыми двумя островами архипелага можно построить путь по этим мостам, причем этот путь единственный. Все острова пронумерованы от 11 до nn. Эйлер находится на острове номер 11 и желает совершить следующую прогулку: с острова номер 11 он хочет дойти до острова номер 22, далее до острова номер 33 и так далее до острова номер nn. С него он хочет вернуться на  остров номер 11. Он прекрасно понимает, что при этом ему придётся посещать некоторые мосты по многу раз. Осталось выяснить, сколько раз суммарно он пройдет по мостам во время своей прогулки.

Формат входных данных

В первой строке содержится число nn - количество островов в архипелаге, 2 \leq n \leq 10^52≤n≤10 
5
 . В следующих n-1n−1 строках содержатся по два числа a_ia 
i
​	
  и b_ib 
i
​	
  через пробел - номера островов, соединённых мостом, 1 \leq a_i, b_i \leq n, a_i \neq b_i1≤a 
i
​	
 ,b 
i
​	
 ≤n,a 
i
​	
 

=b 
i
​	
 . Гарантируется, что между любыми двумя островами архипелага можно построить путь по этим мостам, причем этот путь единственный.

Формат выходных данных

Вывести длину описанного пути, то есть суммарное количество пересечений мостов, которые придётся совершить.
"""
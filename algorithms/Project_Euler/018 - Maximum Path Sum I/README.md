# [Максимальная сумма пути 1](TODO)

## [Проблема](https://euler.jakumo.org/problems/view/18.html)

>Начиная в вершине треугольника (см. пример ниже) и перемещаясь вниз на смежные числа, максимальная сумма до основания составляет 23.
> ```
>      3
>    7   4
>  2   4   6
> 8  5   9   3
> ```
>То есть, `3 + 7 + 4 + 9 = 23`.
>
>Найдите максимальную сумму пути от вершины до основания следующего треугольника:

>Примечание: Так как в данном треугольнике всего 16384 возможных маршрута от вершины до основания, эту задачу можно решить проверяя каждый из маршрутов. Однако похожая Задача 67 с треугольником, состоящим из сотни строк, не решается перебором (brute force) и требует более умного подхода!)

``` python
solution (triangle)  # => 1074 
```

## Частное решение (1)

### Примечание

Идея состоит в том, чтобы пройти по строкам и вычислить сумму значений и чисел, входящих ранее в структуру данных. 

```
3
7 4
2 4 6
8 5 9 3
```

Начиная со второй строки, `7` и `4` могут быть увеличены на Предыдущее значение.

```
10 7
2 4 6
8 5 9 3
```
Однако, продолжая третью строку, мы обнаруживаем, что `4` может быть увеличено как на `10`, так и на `7`. 

```
12 [14 11] 13
 8  5   9  3
```

`14` as in`10+4` and `11` as in `7+4`. Keeping the values in an array means we still have a row with three items, even if those items can actually describe two values.

Продолжая четвертый ряд, мы продолжаем складывать необходимые значения.

```
20 [17 19 16] [23 20 22] 16
```

Более подробно про предыдущий щаг:
- Для `5`:

  - `17 = 12 + 5`
  - `19 = 14 + 5`
  - `16 = 11 + 5`

 Используя возможные числа, описанные в массиве в предыдущей строке, `[14 11]`.

- Для `9`:

  - `23 = 14+9`
  - `20 = 11+9`
  - `22 = 13+9`


- `current` представляет собой массив с одним элементом, представляющим текущее значение в строке

- `north_west` представляет собой массив, детализирующий возможные значения числа в предыдущей строке и предыдущем индексе

- `north_east` возможные значения в предыдущей строке и с тем же индексом.

```python
def num_to_array(triangle):
    """
    Идея:
        3 становится [3], 7 становится [7]. Это немного облегчает суммирование чисел через строки треугольника,
        так как больше нет необходимости проверять, описывает ли предыдущая строка массив или целое число.
    """
    res = triangle.copy()
    for i in range(len(triangle)):
        for j, num in enumerate(triangle[i]):
            if num: res[i][j] = [num]
    return res


# Для каждого числа в `array` прибавляет `current_value`
current_sum = lambda array, current_value: [num + current_value for num in array]


def solution(triangle):
    """Находит максимальную сумму в треугольнике, как описано в постановке задачи выше.

    >>> solution(triangle)
    1074
    """
    result_sum = num_to_array(triangle)
    for i in range(1, len(triangle)):
        for j in range(len(triangle[i])):
            current = result_sum[i][j]
            if (current):
                north_west = result_sum[i - 1][j - 1]
                north_east = result_sum[i - 1][j]

                result_sum[i][j] = []
                current_value = current[0]
                if (north_west):
                    result_sum[i][j] = [*result_sum[i][j], *current_sum(north_west, current_value)]
                if (north_east):
                    result_sum[i][j] = [*result_sum[i][j], *current_sum(north_east, current_value)]
    flatten_result_sum = []
    for arr in result_sum[-1]:
        flatten_result_sum.extend(arr)
    return max(flatten_result_sum)
```

```python
test_triangle = [
  [3, 0, 0, 0],
  [7, 4, 0, 0],
  [2, 4, 6, 0],
  [8, 5, 9, 3]
]
solution(test_triangle)
#Выхлоп: 23
```

| Строка | Сумма                                       |
| --- | ------------------------------------------ |
| 0   | `[[3], 0, 0, 0]`                           |
| 1   | `[[10], [7], [], []]`                      |
| 2   | `[[12], [14, 11], [13], []]`               |
| 3   | `[[20], [17, 19, 16], [23, 20, 22], [16]]` |

## Нормальное решение (1)

Мы создаем новый пустой треугольник с теми же размерами, что и исходный большой треугольник.
Для каждой ячейки большого треугольника рассмотрим под-треугольник, вершина которого находится в этой ячейке,
вычислите максимальную сумму пути при запуске из этой ячейки и сохраните результат
в соответствующей ячейке пустого треугольника.

Если мы начнем с определенной ячейки, какова максимальная сумма путей? Если ячейка находится в
дно большого треугольника, то это просто значение ячейки. В противном случае ответ таков
значение ячейки плюс либо {максимальное общее значение пути ячейки вниз и влево}
или {максимальный суммарный путь ячейки вниз и вправо}, в зависимости от того, что больше.
При вычислении значений пустого треугольника снизу вверх зависимые значения всегда равны
вычисляется до того, как они будут использованы. Этот метод известен как динамическое программирование.

```python
def solution(triangle):
    for row in reversed(range(len(triangle) - 1)):
        for col in range(len(triangle[row])):
            triangle[row][col] += max(triangle[row + 1][col], triangle[row + 1][col + 1])
    return triangle[0][0]
```
# [Постоянная Чамперноуна](TODO)

## [Проблема](https://euler.jakumo.org/problems/view/40.html)

>Дана иррациональная десятичная дробь, образованная объединением положительных целых чисел:
>
>0.12345678910{1}112131415161718192021...
>
>Видно, что 12-ая цифра дробной части - 1.
>
>Также дано, что d_n представляет собой n-ую цифру дробной части. Найдите значение следующего выражения:
>
>d_1 × d_10 × d_100 × d_1000 × d_10000 × d_100000 × d_1000000

``` python
solution  () 210  # =>   PROD{1, 5, 3, 7, 2, 1, 210}
```

## Частное решение (1)

```python
def solution():
    """
    >>> solution()
    ... 210 #  PROD{1, 5, 3, 7, 2, 1, 210}
    """
    result_product = 1
    fraction = '0.' + ''.join([str(n) for n in range(1, 200000)])
    for power in range(2, 7):
        a = int(fraction[10 ** power + 1])
        print('10**', power, ',', a)
        result_product *= a
    return result_product
```

## Частное решение (2)

Можно представить себе константу Чампернауна, как множество рядов сцепленных счетных чисел.
<br>
Каждая серия представляет собой порядок величины следующим образом:

|Серия (к)   |	Диапазон |	Количество чисел | Количество цифр в серии| Кумулятивное количество|
| -----------| :-------:|  ---------------:   |  ---------------:   |  ---|
|1|          	1–9     |	9                  |            	9       |	9|
|2|          	10–99   |	90                 |            	180     |	189|
|3|          	100–999 |	900                |            	2700        |	2889|
|4|          	1000–9999|	9000                   |            	36000       |	38889|
|5|          	10000–99999|	90000                  |            	450000      |	488889|

* Число цифр для каждого члена диапазона - это номер серии, k. То есть серия 4 состоит из 4–значных чисел.

* Диапазон для каждой серии составляет от 10^{к-1} до 10^{к-1} и имеет 9·10^{к-1} чисел.
* Общее число цифр в каждом диапазоне равно k × чиство чисел. Итак, серия 4 имеет 4×9000 = 36 000 цифр.

Мы можем переосмыслить эти диапазоны сцепленных целых чисел как массив с 3 индексами.
Один индекс для диапазоны, один для числа в этом диапазоне, а другой для десятичной позиции внутри числа. 
Все эти индексы будут получены из одного индекса, который описывает определенную цифру внутри константы.
Это стало возможным благодаря организованному построению константы.

Допустим, нам нужна 37-я цифра внутри константы. Частичное разложение константы от 1-25 выглядит следующим образом:

```
123456789101112131415161718192021222{3}2425
```
37-я цифра, выделенна скобками. Представим 37 как 3 индекса следующим образом:


Учитывая, что константа разбита на диапазоны, как описано выше:
<br>Серия 1: 1, 2, 3, 4, 5, 6, 7, 8, 9
<br>
Серия 2: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, ..., 99

1. Ищем серию.
    - определяем 37-ю цифру во 2-й диапазон (10-99) как 9 < 37 ≤ 189.
2. Ищем член в ряду, определив его порядковое положение.
    - Вычисляем 37-9 (кумулятивное количество из предыдущей серии) = 28-й цифре во 2-м диапазоне.
    Тогда (28-1) ÷ 2 = 13 (с остатком 1) - порядковое положение числа.
    - И, наконец, 13+10 (начальное число диапазона) = 23-это значение полученного числа.
3. Ищем правильную позицию цифры в значении числа.
    - Остаток от приведенного выше деления - это нулевой индекс до правильной цифры в значении числа.
     Для этого примера индекс 1- это 2-я цифра 23 = 3.

```python
# количество цифр каждой серии: 9, 180, 2700, ..., 9·x·10^(x−1)
ch_digits_count = [9 * (x + 1) * 10 ** x for x in range(20)]


def get_digit(indicies):
    '''Возразает цифру в позиции indicies из постоянной Чамперноуна'''
    i = 0
    while indicies > ch_digits_count[i]:
        indicies -= ch_digits_count[i]
        i += 1
    L, d = divmod((indicies - 1), i + 1)
    return int(str(10 ** i + L)[d])


def solution():
    """
    >>> solution()
    ... 210 # =>   PROD{1, 5, 3, 7, 2, 1, 210}
    """
    result_product = 1
    for power in range(2, 7):
        ch_digit = get_digit(10 ** power)
        result_product *= ch_digit
    return result_product
```
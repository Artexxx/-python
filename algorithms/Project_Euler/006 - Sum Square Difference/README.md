# [Разность между суммой квадратов и квадратом суммы](TODO)

## [Проблема](https://euler.jakumo.org/problems/view/6.html)

>Сумма квадратов первых десяти натуральных чисел равна
>
><div style="text-align:center;">1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385</div>
>
>Квадрат суммы первых десяти натуральных чисел равен
>
><div style="text-align:center;">(1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025</div>
>
>Следовательно, разность между суммой квадратов и квадратом суммы первых десяти натуральных чисел составляет 3025 - 385 = 2640.
>
>Найдите разность между суммой квадратов и квадратом суммы первых n натуральных чисел.

``` python
solution(10) # => 2640
solution(15) # => 13160
solution(20) # => 41230
solution(50) # => 1582700
```

## Частное решение (1)

``` python
def solution(n):
   sum_of_squares = 0
    square_of_sum = 0
    for i in range(1, n + 1):
        sum_of_squares += i ** 2
        square_of_sum += i
    result_number = square_of_sum ** 2 - sum_of_squares
    return result_number
```
```text
  №      Время  Замедление       Число                     Результат
---  ---------  ------------  --------  ----------------------------
  1  0.0027122  0.271%           10000              2500166641665000
  2  0.0249964  2.23%           100000          25000166664166650000
  3  0.244371   21.94%         1000000      250000166666416666500000
  4  2.3986     215.42%       10000000  2500000166666641666665000000
```
*[-] Проходит все числа до N*, эффективнее было-бы использовать формулу суммы арифметической прогрессии.
Поэтому более эффективный подход будет опираться на формулы.


## Общее решение (1)
> если взять [1, 2, 3, 4, 5, 6, 7] и посмотреть на пару из первого числа и последнего, 
> а потом на пару из второго числа и предпоследнего, то их суммы равны [1+7] = [2+6] => общая сумма последовательности 
> равна сумме всех пар => S(7) =  (7/2) * 8
>
>Общая формула будет выглядить так: (n/2)*(n+1) = n(n+1)/2


- Квадрат суммы будет получен следующей формулой: <img src='https://render.githubusercontent.com/render/math?math=(\frac{N(N + 1)}{2} )^2'>
- Сумма квадратов: <img src='https://render.githubusercontent.com/render/math?math=\frac{N(N + 1)(2N + 1)}{6}'>

- Разность <img src='https://render.githubusercontent.com/render/math?math=s_1 - s_2 = (N^4 / 4) + (N^3 / 6) - (N^2 / 4) - (N / 6)'>

``` python
def solution(n):
    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6
    square_of_sum = (n * (n + 1) / 2) ** 2
    return int(square_of_sum - sum_of_squares)

#    or    #

solution = lambda n: (n ** 4 / 4) + (n ** 3 / 6) - (n ** 2 / 4) - (n / 6)
```
```text
  №    Время  Замедление      Аргумент                     Результат
---  -------  ------------  ----------  ----------------------------
  1  4.2e-06  0.000%             10000              2500166641665000
  2  2e-06    -0.000%           100000          25000166664166649856
  3  1.4e-06  -0.000%          1000000      250000166666416638918656
  4  1.5e-06  0.000%          10000000  2500000166666642048298254336
```


## Частное решение (2)

Начну с рассмотрения нескольких произвольных значений:

| Input | Sum of the squares | Square of the sum | Difference |
| ----- | ------------------ | ----------------- | ---------- |
| 2     | 1^2 + 2 ^ 2 = 5    | (1+2)^2 = 9       | 4          |
| 3     | 14                 | 36                | 22         |
| 4     | 30                 | 100               | 70         |
| 5     | 55                 | 225               | 170        |
| 6     | 91                 | 441               | 350        |
| 7     | 140                | 784               | 644        |
| 8     | 204                | 1296              | 1092       |
| 9     | 285                | 2025              | 1740       |
| 10    | 385                | 3025              | 2640       |

Глядя на столбец _difference_ и разницу между каждой последующей записью, можно заметить кое-что интересное.

Каждое приращение можно описать как квадрат входного числа, умноженного на число, предшествующее ему: `n^2*(n-1)`.

| Difference | Delta | Result   |
| ---------- | ----- | -------- |
| 4          | 4     | 2^2 \*1  |
| 22         | 18    | 3^2\*2   |
| 70         | 48    | 4^2\*3   |
| 170        | 100   | 5^2\*4   |
| 350        | 180   | 6^2\*5   |
| 644        | 294   | 7^2\*6   |
| 1092       | 448   | 8^2\*7   |
| 1740       | 648   | 9^2\*8   |
| 2640       | 900   | 100^2\*9 |

Я могу пойти здесь на крайность, но, возможно, это отношение действительно может дать решение.
Поскольку разность увеличивается со скоростью `n^2*(n-1)`, можно решить задачу рекурсивно,
 рассматривая все меньшие и меньшие значения, каждый раз добавляя значение, описываемое новообретенным выражением.


```python
def solution(n):
    if n == 1: return 0
    return n ** 2 * (n - 1) + solution(n - 1)
```

*[-] Хвостовую рекурсию лучше не использовать,* поскольку компилятор Python не обрабатывает оптимизацию для хвостовых рекурсивных вызовов.
 В таких случаях рекурсивное решение использует больше системных ресурсов, чем итеративное.
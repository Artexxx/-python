# [Спиральные простые числа](TODO)
## [Проблема](https://euler.jakumo.org/problems/view/57.html)


>Можно убедиться в том, что квадратный корень из двух можно выразить в виде бесконечно длинной дроби.
<br>√ 2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...
>
><p class="center monospace"><span class="red"><b>37</b></span> 36 35 34 33 32 <span class="red"><b>31</b></span><br />
38 <span class="red"><b>17</b></span> 16 15 14 <span class="red"><b>13</b></span> 30<br />
39 18 <span class="red"> <b>5</b></span>  4 <span class="red"> <b>3</b></span> 12 29<br />
40 19  6  1  2 11 28<br />
41 20 <span class="red"> <b>7</b></span>  8  9 10 27<br />
42 21 22 23 24 25 26<br /><span class="red"><b>43</b></span> 44 45 46 47 48 49</p>

>Следующие три приближения: 99/70, 239/169 и 577/408, а восьмое приближение, 1393/985, является первым случаем, в котором количество цифр в числителе превышает количество цифр в знаменателе.
>
>У скольких дробей длина числителя больше длины знаменателя в первой тысяче приближений

``` python
solution  (1000) => 153
```

## Частное решение (1)

```python
def solution(proportion=0.1):
    """
    Возвращает длину стороны квадратной спирали, у которой отношение количества простых чисел к количеству всех чисел на обеих диагоналях ниже 10%.

    Идея из решения 28 проблемы:
        Рассмотрим спираль, приведенную в примере.

        | digit | Index |
        | ----- | ----- |
        | 1     | 0     |
        | 3     | 2     |
        | 5     | 4     |
        | 7     | 6     |
        | 9     | 8     |
        | 13    | 12    |
        | 17    | 16    |
        | 21    | 20    |
        | 25    | 24    |

        При прохлждении каждого квадрата индекс нужного числа увеличивается на 2, потом на 4, потом на 6..., до тех пор,
          пока мы не достигнем цифры, завершающей сетку.
    """
    counter = 1
    increment = 2
    count_primes = 0
    count_diagonals_numbers = 1
    while True:
        for _ in range(4):
            counter += increment
            if is_prime(counter):
                count_primes += 1

        increment += 2
        count_diagonals_numbers += 4

        if count_primes / count_diagonals_numbers < proportion:
            side_length = int(counter**0.5)
            return side_length, count_primes, count_diagonals_numbers
```
```text
   №      Время  Замедление      Аргумент    Результат
---  ---------  ------------  ----------  -----------
  1  0.0008331  0.083%               0.2          309
  2  2.26441    226.358%             0.1        26241 (Ответ)
```

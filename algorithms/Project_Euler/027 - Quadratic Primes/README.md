# [Квадратичные простые числа](TODO)

## [Проблема](https://euler.jakumo.org/problems/view/27.html)

> Эйлер опубликовал свою замечательную квадратичную формулу:
> 
> `n^2+n+41`
> 
> Оказалось, что согласно данной формуле можно получить 40 простых чисел, последовательно подставляя значения `0≤n≤39`.
>  Однако, при `n=40`,`40^2+40+41=40(40+1)+41` делится на 41 без остатка, и, очевидно, при `n=41`,`41^2+41+41` делится на 41 без остатка.
> 
> При помощи компьютеров была найдена невероятная формула `n^2−79n+1601`, согласно которой можно получить 80 простых чисел для последовательных значений n от 0 до 79. 
> Произведение коэффициентов −79 и 1601 равно −126479.
> 
> Рассмотрим квадратичную формулу вида:
> 
> `n^2+an+b`, где `|a| < range`и `|b| ≤ range` где `|n|` является модулем (абсолютным значением) `n`.
> 
> Найдите произведение коэффициентов `a` и `b` квадратичного выражения, согласно которому можно получить максимальное количество простых чисел для последовательных значений `n`, начиная со значения `n=0`.


``` python
solution   (10)  # => -21
solution  (100)  # => -1455
solution (1000)  # => -59231
```

## Примечание (1)

Преобразуем квадратичное выражение.
```code
n^2 + a*n + b = prime
0 + 0 + b = prime
b = prime
```
Поскольку выражение должно найти простое число, то `b` должно быть само простым.
 Мало того, оно должна быть еще и положительным. 
 Это происходит потому, что ***простое число*** — это натуральное число больше 1, которое не может быть образовано путем умножения двух меньших натуральных чисел.


## Частное решение (1)

Ключом к решению этой проблемы является сокращение пространства поиска.


```python
def solution(LIMIT):
    """ Возвращает произведение коэффициентов a и b квадратичного выражения, согласно которому можно получить максимальное
        количество простых чисел для последовательных значений n, начиная с значения n=0.

    >>> solution(1000)
    -59231 # n^2 + an + b = n^2 - 61*n + 971
    """

    class result:
        n, a, b = 0, 0, 0

    for a in range(-LIMIT + 1, LIMIT):
        if a % 2 == 0: continue
        for b in primes_sieve(LIMIT):
            n = 0
            while is_prime(n * (n + a) + b):
                n += 1

            if n > result.n:
                result.n = n
                result.a = a
                result.b = b

    print(f"n^2 + an + b = n^2{result.a:+}*n{result.b:+}")
    return result.a * result.b
```
```text
  №      Время  Замедление      Аргумент    Результат
---  ---------  ------------  ----------  -----------
  1  0.0001656  0.017%                10          -21
  2  0.0072277  0.706%               100        -1455
  3  0.390135   38.291%             1000       -59231 <Ответ>
```
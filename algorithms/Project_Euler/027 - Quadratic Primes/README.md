# [Квадратичные простые числа](TODO)

## [Проблема](https://euler.jakumo.org/problems/view/27.html)

> Эйлер опубликовал свою замечательную квадратичную формулу:
> 
> `n^2+n+41`
> 
> Оказалось, что согласно данной формуле можно получить 40 простых чисел, последовательно подставляя значения `0≤n≤39`.
>  Однако, при `n=40`,`40^2+40+41=40(40+1)+41` делится на 41 без остатка, и, очевидно, при `n=41`,`41^2+41+41` делится на 41 без остатка.
> 
> При помощи компьютеров была найдена невероятная формула `n^2−79n+1601`, согласно которой можно получить 80 простых чисел для последовательных значений n от 0 до 79. 
> Произведение коэффициентов −79 и 1601 равно −126479.
> 
> Рассмотрим квадратичную формулу вида:
> 
> `n^2+an+b`, где `|a| < range`и `|b| ≤ range` где `|n|` является модулем (абсолютным значением) `n`.
> 
> Найдите произведение коэффициентов `a` и `b` квадратичного выражения, согласно которому можно получить максимальное количество простых чисел для последовательных значений `n`, начиная со значения `n=0`.


``` python
solution   (10)  # => -21
solution  (100)  # => -1455
solution (1000)  # => -59231
```

## Примечание (1)

Глядя на квадратичное выражение, мы можем сразу же обновить возможные значения для b.
```code
n^2 + a*n + b = prime
0 + 0 + b = prime
b = prime
```
Поскольку выражение должно найти простое число, `b` должно быть само простым.
 Мало того, оно должна быть еще и позитивной. 
 Это происходит потому, что ***простое число***-*это натуральное число больше 1, которое не может быть образовано путем умножения двух меньших натуральных чисел.*

мы можем обновить значения для `b` в диапазоне `1 <= b <= range`, который состоит из простых чисел.

>Используя **сито Эратосфена**, мы можем найти простые числа ниже порога `range`.


## Частное решение (1)

Ключом к решению этой проблемы является сокращение пространства поиска.


```python
def solution(LIMIT):
    primesRange = bit_sieve_optimized(LIMIT)

    class solution:
        n = 0
        a = 0
        b = 0

    for i in range(0, len(primesRange)):
        b = primesRange[i]
        for a in range(LIMIT * -1 + 1, LIMIT):
            if not (b == 2 and a % 2 != 0):
                for n in itertools.count(1):
                    temp_prime_formula = n ** 2 + a * n + b
                    if not (temp_prime_formula in primesRange
                            or temp_prime_formula > primesRange[-1]
                            and is_prime(temp_prime_formula)
                    ):
                        break  # нам нужно n
                    # assert n > LIMIT
                if n > solution.n:
                    solution.n = n
                    solution.a = a
                    solution.b = b

    return solution.a * solution.b

```
```text
  №      Время  Замедление      Число    Результат
---  ---------  ------------  -------  -----------
  1  9.52e-05   0.010%             10          -21
  2  0.0071047  0.70%             100        -1455
  3  0.808275   80.12%           1000       -59231
```
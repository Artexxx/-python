# [Словарные перестановки](TODO)

## [Проблема](https://euler.jakumo.org/problems/view/24.html)


> ***Перестановка*** - это упорядоченная выборка объектов. 
> 
> К примеру, 3124 является одной из возможных перестановок из цифр 1, 2, 3 и 4. 
> Если все перестановки приведены в порядке возрастания или алфавитном порядке, то такой порядок будем называть словарным.
>  Словарные перестановки из цифр 0, 1 и 2 представлены ниже:
> 
> 012   021   102   120   201   210
> 
> Какова миллионная словарная перестановка из цифр `0, 1, 2, 3, 4, 5, 6, 7, 8 и 9`?

``` python
solution   ()  # => 2_783_915_460
```

## Частное решение (0)
```python
def solution():
    result = list(map("".join, permutations("0123456789")))
    return result[999999]


# Аналогичное решение
solution2 = ''.join(list(permutations('0123456789'))[10**6 - 1])
```

## Общее решение (1)

```python
factorial(10) # => 3_628_800
```
Сейчас я попробую объяснить свой подход. Мы знаем, что существует три с лишним миллиона способов упорядочить числа.
Однако если бы мы зафиксировали первую цифру, например, `1`, то это число свелось бы к:

```python
factorial(9)  # =>  362_880
```
Если мы знаем это, мы приходим к пониманию, что есть `362880` возможности, прежде чем мы исчерпаем каждую строку, начинающуюся с числа `0`
Другими словами, `1023456789` - это `362881-я ` цифра в серии.


- `2013456789` должено быть `362880 * 2 + 1 = 725761-е` значение.

`699999-е` число начинается с `1`; `899999-е`- с `2`.
<br>Давайте рассмотрим `699999` поэтапно:
- вычисляем факториал `9`: `362880`
- вычисляем целочисленное деление между заданным числом и факториалом: `int(699999 / 362880) = 1`
- вычисляем разницу: `699999 - 362880 = 337119` 

Учитывая это, мы уже знаем, что строка начинается с `1`. 
<br>Более того, мы начинаем искать `337119-е` число из оставшихся символов.
<br>Повторение той же логики для одной цифры меньше:
- вычисляем факториал `8`: `40320`
- вычисляем целочисленное деление между заданным числом и факториалом: `int(337119 / 40320) = 8`
- вычисляем разницу: `699999 - 362880 = 337119` 

Мы использовали `1`  поэтому восьмое значение на самом деле `9`.


Индекс  | Факториал|целочисленное деление| Последовательность|	Оставшиеся|	Разница      |
| ------ | --------- | ---------------- | ---------- | --------- | --------------------- |
| 699999 | 362880    | 1                | 1          | 023456789 | `699999 - 362880 * 1` |
| 337119 | 40320     | 8                | 19         | 02345678  | `337119 - 40320 * 8`  |
| 14559  | 5040      | 2                | 193        | 0245678   | `14559 - 5040 * 2`    |
| 4479   | 720       | 6                | 1938       | 024567    | `4479 - 720 * 6`      |
| 159    | 120       | 1                | 19382      | 04567     | `159 - 120 * 1`       |
| 39     | 24        | 1                | 193824     | 0567      | `39 - 24 * 1`         |
| 15     | 6         | 2                | 1938246    | 057       | `15 - 6 * 2`          |
| 3      | 2         | 1                | 19382465   | 07        | `3 - 2 * 1`           |
| 1      | 1         | 1                | 193824657  | 0         | `1 - 1 * 1`           |
| 0      | 1         | 0                | 1938246570 |           | `0`                   |


```python
def solution(N) -> int:
    """Возращает миллионную словарнаю перестановка из цифр 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9.

     >>> solution()
     2_783_915_460
     """
    # отрегулирован номер перестановки, чтобы он был проиндексирован на ноль
    n = N - 1
    digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

    # определется каждая цифра N-й лексикографической перестановки
    digit_count = len(digits)
    permutation_digits = []
    # for i in range(digit_count, 0, -1):
    for i in range(1, digit_count):
        digit, n = divmod(n, factorial(digit_count - i))
        permutation_digits.append(digits[digit])
        del digits[digit]

    # добавляется оставшаяся цифра
    permutation_digits.append(digits[0])
    return int(''.join(permutation_digits))

def solution_1(POS):
    """ Аналогичное решение """
    digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
    permutation_digits = []

    # Индекс позиции - это как в списке. N-й элемент - это элемент с индексом n-1
    pos = POS - 1
    for i in reversed(range(len(digits))):
        c = pos // factorial(i)  # math.floor
        permutation_digits.append(digits[c])
        digits.remove(digits[c])
        pos = pos - c * factorial(i)
    return int(''.join(permutation_digits))

```



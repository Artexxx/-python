# [Пятые степени цифр](TODO)

## [Проблема](https://euler.jakumo.org/problems/view/30.html)

> Удивительно, но существует только три числа, которые могут быть записаны в виде суммы четвертых степеней их цифр:
>
>1634 = 1<sup>4</sup> + 6<sup>4</sup> + 3<sup>4</sup> + 4<sup>4</sup><br>
8208 = 8<sup>4</sup> + 2<sup>4</sup> + 0<sup>4</sup> + 8<sup>4</sup><br>
9474 = 9<sup>4</sup> + 4<sup>4</sup> + 7<sup>4</sup> + 4<sup>4</sup>
>
>Сумма этих чисел равна 1634 + 8208 + 9474 = 19316.
>
>Найдите сумму всех чисел, которые могут быть записаны в виде суммы пятых степеней их цифр.


``` python
solution   (4)  # => 19316 = 1634, 8208, 9474
solution   (5)  # => 443839 = 4150,4151,54748,92727,93084,194979
```



## Частное решение (1)

__Нахождение границ:__

(9^5)=59_049 => 59049*7=413_343 (это всего лишь 6-значное число 999_999)
<br>Таким образом, число, превышающее `999_999`, отклоняется
а также 59049*3=`1_77_147` (что превышает критерии числа, являющегося 3-значным)
Итак, n>`999` и n<`999_999`, следовательно, граница равна `(1000,1000000)`

```python
def is_digit_sum(s: str) -> int:
    """
    Проверяет можетли число S записано в виде суммы пятых степеней его цифр:
    [*] Возращает 0 или S

    >>> is_digit_sum('4150')
    4150 #=> [1024, 1, 3125, 0]
    >>> is_digit_sum('4151')
    4151 #=> [1024, 1, 3125, 1]
    """
    i = sum(pow(int(c), 5) for c in s)
    if i == int(s):
        print(str(i) + ", ")
    return i if i == int(s) else 0


def solution():
    count = sum(is_digit_sum(str(i)) for i in range(1000, 1000000))
    return count

```
```text
  №      Время  Замедление      Число    Результат
---  ---------  ------------  -------  -----------
  1     2.3675  226,4%              5       443839
```

## Примечание (1)

Идея сокращения пространство поиска поиска заключается в следующем: можно делать перебор не самих чисел, а значений,
которые могут получаться в результате степенной суммы ( т.е. суммы цифр числа, возведенных в степень числа цифр этого числа ).

В приведенной выше постановке задачи в качестве первого примера, удовлетворяющего требованию суммирования степеней,
было использовано `1634`. Становится очевидным, что различные комбинации `1634` (1643, 1346, 1364, 1436, 1463, 3146, 3164, 3416, 3461, 3614, 3641, 4136, 4163, 4316, 4361, 4613, 4631, 6134, 6143, 6314, 6341, 6413, 6431)
будут иметь одну и ту же сумму степенных цифр. Ясно, что мы можем исключить все, кроме одной комбинации, и просто проверить этого кандидата из набора.


Итак, вышеописанный метод снизил число перебираемых чисел с `10^9` до приблизительно `200000`.
Поскольку все числа оцениваются в одну и ту же степенную сумму в силу коммутативного закона сложения,
не имеет значения, какое число из множества мы выбираем, пока его степенная сумма, подвергнутая тому же процессу, равна разрядам суммы и уникальна в поиске.

**Пример:** возьмём произвольное число из приведенного выше набора, скажем `3614`, и суммируйте 4-ю степень его цифр.
Сумма равна `1634`, как и для любого числа в наборе. Теперь давайте проделаем тот же самый расчет на сумму, `1634`: 14+64+34+44 = `1634`.
Когда две суммы равны, `1634` является успешным кандидатом из множества.


Итак, вышеописанный метод снизил число перебираемых чисел с 10^9 до приблизительно 200000.
Но это не все на чем стоит остановливаться. Можно применить еще одну хитрость, которая заключается в следующем:
можно значительно ускорить вычисление степенной суммы. Можно заметить, что при вычислениях часто приходится многократно
 возводить некоторое число в некоторую степень, нужно использовать простую **мемоизацию**.
 
 
<ul>
<table>
<tbody><tr>
<th><ya-tr-span data-index="32-0" data-value="Power" data-translation="Сила" data-type="trSpan">Power</ya-tr-span><p></p>
</th><th><ya-tr-span data-index="33-0" data-value="Number Set" data-translation="Набор Чисел" data-type="trSpan">Number Set</ya-tr-span></th></tr>
<tr>
<td>2<p></p>
</td><td><ya-tr-span data-index="34-0" data-value="*NONE*" data-translation="*НИКТО*" data-type="trSpan">*NONE*</ya-tr-span></td></tr>
<tr>
<td>3<p></p>
</td><td>153, 370, 371, 407</td></tr>
<tr>
<td>4<p></p>
</td><td>1634, 8208, 9474</td></tr>
<tr>
<td>5<p></p>
</td><td>4150, 4151, 54748, 92727, 93084, 194979</td></tr>
<tr>
<td>6<p></p>
</td><td>548834</td></tr>
<tr>
<td>7<p></p>
</td><td>1741725, 4210818, 9800817, 9926315, 14459929</td></tr>
<tr>
<td>8<p></p>
</td><td>24678050, 24678051, 88593477</td></tr>
<tr>
<td>9<p></p>
</td><td>146511208, 472335975, 534494836, 912985153</td></tr>
<tr>
<td>10<p></p>
</td><td>4679307774</td></tr>
<tr>
<td>11<p></p>
</td><td>32164049650, 40028394225, 42678290603, 44708635679, 49388550606, 32164049651, 82693916578, 94204591914</td></tr>
<tr>
<td>12<p></p>
</td><td><ya-tr-span data-index="35-0" data-value="*NONE*" data-translation="*НИКТО*" data-type="trSpan">*NONE*</ya-tr-span></td></tr>
<tr>
<td>13<p></p>
</td><td>564240140138</td></tr>
<tr>
<td>14<p></p>
</td><td>28116440335967</td></tr>
<tr>
<td>15<p></p>
</td><td><ya-tr-span data-index="36-0" data-value="*NONE*" data-translation="*НИКТО*" data-type="trSpan">*NONE*</ya-tr-span></td></tr>
<tr>
<td>16<p></p>
</td><td>4338281769391370, 4338281769391371</td></tr>
<tr>
<td>17<p></p>
</td><td>233411150132317, 21897142587612075, 35641594208964132, 35875699062250035 </td></tr>
<tr>
<td>18<p></p>
</td><td><ya-tr-span data-index="37-0" data-value="*NONE*" data-translation="*НИКТО*" data-type="trSpan">*NONE*</ya-tr-span></td></tr>
<tr>
<td>19<p></p>
</td><td>1517841543307505039, 3289582984443187032, 4498128791164624869, 4929273885928088826</td></tr>
<tr>
<td>20<p></p>
</td><td>63105425988599693916</td></tr>
</tbody></table>
</li></ul>

## Улучшенное решение (1)

__Использование комбинаций__

```python
from itertools import combinations_with_replacement

ex, s = int(input('Exponent? ')), 0
p = {str(i): i ** ex for i in range(10)}

isis = 1
for cx in combinations_with_replacement('0123456789', ex + (ex >= 5)):
    isis += 1
    t = sum(p[x] for x in cx)
    sd = sum(p[x] for x in str(t))
    if t == sd and t > 9: s += t

print("Sum of power digits for exponent", ex, "is", (s if s > 0 else "*NONE*"))
```


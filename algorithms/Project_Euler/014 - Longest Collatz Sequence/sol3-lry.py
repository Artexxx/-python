"""
Следующая повторяющаяся последовательность определена для множества натуральных чисел:
    n → n/2 (n - четное)
    n → 3n + 1 (n - нечетное)

Используя описанное выше правило и начиная с 13, сгенерируется следующая последовательность:
    13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1

Получившаяся последовательность (начиная с 13 и заканчивая 1) содержит 10 элементов.
Хотя это до сих пор и не доказано (проблема Коллатца (Collatz)), предполагается, что все сгенерированные таким образом последовательности оканчиваются на 1.

Какой начальный элемент меньше миллиона генерирует самую длинную последовательность?

  №      Время  Замедление      Число    Результат
---  ---------  ------------  -------  -----------
  1  0.000873   0.087%           1000          871
  2  0.0066451  0.58%           10000         6171
  3  0.0803638  7.37%          100000        77031
  4  0.882243   80.19%        1000000       837799
"""
from functools import lru_cache


@lru_cache(maxsize=None)
def collatz_chain_length(x):
    if x == 1: return 1
    if x % 2 == 0:
        y = x // 2
    else:
        y = x * 3 + 1
    return collatz_chain_length(y) + 1


def solution(n):
    """Возвращает число меньше n, которое генерирует самую длинную последовательность Коллатца

       n → n/2 (n - четное)
       n → 3n + 1 (n - нечетное)

    >>> solution(1000000)
    837799
    >>> solution(200)
    171
    >>> solution(5000)
    3711
    >>> solution(15000)
    13255
    """
    return max(range(1, n), key=collatz_chain_length)

if __name__ == '__main__':
    print(solution(10 ** 6))
    ### Run Time-Profile Table ###
    # import sys; sys.path.append('..')
    # from time_profile import my_time_this
    # my_time_this(solution, [1000, 10_000, 100_000, 10 ** 6])
